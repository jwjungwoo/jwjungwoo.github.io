---
layout: single
title:  "OTA"
categories: autoever
tag: 
author_profile: false #true면 글 안에서 내 프로필 보여줌
sidebar:
    nav: "counts"
#search: false
---

# 느낀점


# OTA 개요

## 과정

ota 는 다운로드와 설치 단계가 있다. 다운로드는 주행중해도되지만 설치는 주차돼있을때 해야한다.   

sota: 쉬움   
   
fota: 하드웨어를 다룰 수 있는 low level control 을 할 수 있다.   

centralized architecture: 이 아키텍처가 표준화되어야한다.   

```c
수직 구성

OTA Server : DM(Download Management) Master  
ㅣ
ㅣ<Wireless Comm. lte. 얘만 무선>
ㅣ

DCU (Modem) : 서버와 무선통신 수행(LTE, WiFi, WAVE, etc)
ㅣ
ㅣ<In-Vehicle Network, 여기서부턴 유선>
ㅣ
Master ECU : DM Client 및 OTA Master 를 포함.
버전 체크, 무선 다운로드, 리프로그래밍 수행
ROM file 관리, OTA 우선순위 판단 등을 수행
ㅣ
ㅣ
ㅣ
Target ECU
```
   
✅ ECU 엔 업데이트 영역과 작동 영역으로 a,b 두 개로 나눠진다.   
<img src="https://github.com/user-attachments/assets/d9c42c29-e48d-45ae-a473-1a8e377187bf" width="900" height="330">   

## TUF

freshness 라는게 차이가 나는 속성이 있다. 이유에 대해서 한번 다시 보자.   

# 실습

## 서버세팅

책에 나와있는대로 세팅하고, <https://mosquitto.org/download/> 에 들어가서 mosquitto-64 로 다운받으면된다.   
   
```c
1. 라즈베리파이세팅
2. C:/programs에 있는 mosquito 를 우클릭하여 cmd 로 열기 한다.
3. 라즈베리파이를 broker 로 만들거다.
4. 가상환경 세팅을 했던거같다.
5. 라즈베리파이 업데이트를 한다.

이후는 책을 따라한다.
```

## mosquitto broker pub1, sub2 개

아 그리고 우선 vim 설치도 하고 세팅도했다.(구글링 고고)   
✅ putty 로 pubisher 1개, sub 2개를 설정했다.   
<img src="https://github.com/user-attachments/assets/e25477db-f07e-4a7b-810b-2794480ac58c" width="900" height="640">   

# 실습

## 서버에서 매번 같은 메세지를 발생시키게하기

p.96의 그림을 참고하면된다. 

새로운 폴더를 만들고 그 안에 py 파일을 하나 새로 만들었다.   

```c
pip install paho-mqtt
```

아래의 코드를 실행하면 server에서 동작하는거고, 보낸 메세지는 브로커 하나를 통해 subscriber 에게 간다.   
✅ publisher_message.py   
```python
import paho.mqtt.client as mqtt

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("Connected to broker")
    else:
        printf(f"Connection failed with code {rc}")

def on_disconnect(client, usedata, rc):
    print("Disconnected from broker, code:", rc)

def on_publish(client, userdata, mid):
    print(f"Message {mid} published successfully")

def send_message_to_broker(message, broker_ip, username, password, port=1883):
    client = mqtt.Client()

    client.on_connect = on_connect
    client.on_disconnect = on_disconnect
    client.on_publish = on_publish

    client.username_pw_set(username, password)

    client.connect(broker_ip, port=port)

    client.loop_start()

    client.publish(topic, message)

    client.loop_stop()
    client.disconnect()

if __name__ == "__main__":
    topic = 'message'
    broker_ip = '192.168.137.171'
    username = input("Enter username: ")
    password = input("Enter password: ")
    message = input("Enter message to publish: ")
    send_message_to_broker(message, broker_ip, username, password)
```   
![1234](https://github.com/user-attachments/assets/18c1a32e-b8df-4f01-a4f9-a80a6fe0d964)   

## 서버에서 실행하면 tier 에 따라 차등 기능 제공

✅ publish_message_id_tier.py   
```python
import paho.mqtt.client as mqtt
import json
import os

status = 'login'

def change_status(new_status):
    global status
    status = new_status

def on_connect(client, userdata, flags, rc):
    pass

def on_disconnect(client, userdata, rc):
    pass

def on_publish(client, userdata, mid):
    print("Message published with mid: " + str(mid))

def main():
    global status
    broker_ip = '192.168.137.171'
    client = mqtt.Client()
    client.on_connect = on_connect
    client.on_disconnect = on_disconnect
    client.on_publish = on_publish
    change_status('login')

    # Load user data from pwfile.json
    with open(os.path.join(os.path.dirname(os.path.abspath(__file__)),'pwfile.json'), 'r') as f:
        user_data = json.load(f)

    # Load topic data from topic_tier_list.json
    with open(os.path.join(os.path.dirname(os.path.abspath(__file__)),'topic_tier_list.json'), 'r') as f:
        topic_data = json.load(f)

    while status == 'login':
        username = input("Enter username: ")
        password = input("Enter password: ")

        # Validate username and password
        if username in user_data and user_data[username]["pw"] == password:
            user_tier = user_data[username]["Tier"]
            print(f"Login successful. Your Tier: {user_tier}")
        else:
            print("Invalid username or password.")
            continue

        client.username_pw_set(username, password)
        client.connect(broker_ip, port=1883)
        client.loop_start()

        change_status('topic')

        while status == 'topic':
            tier_key = f"Tier-{user_tier}"
            if tier_key in topic_data:
                print("Available topics:")
                for idx, topic in enumerate(topic_data[tier_key]["topics"], start=1):
                    print(f"{idx}: {topic}")
            else:
                print(f"No topics available for Tier-{user_tier}.")
                continue

            topic_idx = input("Enter topic number: ")

            # Validate topic selection
            try:
                topic_idx = int(topic_idx) - 1
                if 0 <= topic_idx < len(topic_data[tier_key]["topics"]):
                    topic = topic_data[tier_key]["topics"][topic_idx]
                    change_status('message')
                else:
                    print("Invalid topic number.")
                    continue
            except ValueError:
                print("Invalid input. Please enter a number.")
                continue

            while status == 'message':
                message = input(f"Enter message to publish {topic}: ")
                client.publish(topic, message)
                client.loop_stop()

if __name__ == "__main__":
    main()
```   
![스크린샷 2025-04-18 164555](https://github.com/user-attachments/assets/eeef62d8-e20e-4583-803a-5d1e449d5375)   

## 서버가 subscriber 가 되기

```python
import paho.mqtt.client as mqtt
import os

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("Connected to MQTT Broker!")
    
    elif rc == 5:
        print("Connection refused: not authorized")
    
    else:
        print("Connection failed with code:", rc)

def on_disconnect(client, userdata, rc):
    if rc == 0:
        print("Disconnected from MQTT Broker!")
    elif rc ==5:
        username = input("Enter username: ")
        password = input("Enter password: ")
        client.username_pw_set(username, password)
    elif rc !=0:
        print("Unexpected disconnection with code:", rc)

def on_message(client, userdata, msg):
    try:
        payload = msg.payload.decode()
        print(f"Received message '{payload}' on topic '{msg.topic}'")
    except Exception as e:
        print(f"Error decoding message: {e}")

def receive_message_to_broker(broker_ip, username, password, topic, port=1883):
    client = mqtt.Client()
    
    client.on_connect = on_connect
    client.on_disconnect = on_disconnect
    client.on_message = on_message

    client.username_pw_set(username, password)

    client.connect(broker_ip, port=port)

    client.subscribe(topic)
    print(f"Subscribed to topic '{topic}'")
    client.loop_forever()


if __name__ == "__main__":
    broker_ip = "192.168.137.171"
    topic = "topic"
    username = input("Enter username: ")
    password = input("Enter password: ")
    receive_message_to_broker(broker_ip, username, password, topic)
```   
   
![sub](https://github.com/user-attachments/assets/be1cb1e0-0e00-4316-80bd-98b5523012f6)   

## 전선 연결해서 CAN 통신

✅ kvaser_base.py   
컴퓨터에서 라즈베리파이로 캔통신으로 보내기.   
![스크린샷 2025-04-21 140852](https://github.com/user-attachments/assets/68486c93-d49a-4d9a-841d-c34e6edfc397)   
통신이 되면 위의 사진처럼 뭐가 뜬다.
```python
from canlib import canlib, Frame
import time

# Kvaser 연결 및 설정 class
class Kvaser:
    def __init__(self, channel=0):
        self.channel = channel
        self.openFlags = canlib.canOPEN_ACCEPT_VIRTUAL
        self.bitrate = canlib.canBITRATE_125K
        self.bitrateFlags = canlib.canDRIVER_NORMAL

        self.valid = False
        self.ch = None
        self.device_name = ''
        self.card_upc_no = ''
        try:
            self.ch = canlib.openChannel(self.channel, self.openFlags)
            self.ch.setBusOutputControl(self.bitrateFlags)
            self.ch.setBusParams(self.bitrate)
            self.ch.iocontrol.timer_scale = 1
            self.ch.iocontrol.local_txecho = True
            self.ch.busOn()
            self.valid = True
            self.device_name = canlib.ChannelData.channel_name
            self.card_upc_no = canlib.ChannelData(self.channel).card_upc_no
        except canlib.exceptions.CanGeneralError as e:
            print(f"Error initializing Kvaser channel: {e}")
            self.valid = False
            self.ch = None

    def __del__(self):
        if self.ch:
            self.tearDownChannel()


    def read(self, id, timeout_ms=-1): #CAN read 대기시간
        #CAN 메시지를 읽도록 작성
        try:
            result = self.ch.read(timeout=timeout_ms)
            if result.id == id:
                return result
        except canlib.canNoMsg:
            print("No message received")

        except canlib.canError as e:
            print(f"Error reading from Kvaser channel: {e}")
        return None

    def mkdata(self, data):
        #데이터 형태를 CAN에 적합하도록 변경
        pass
      
    def transmit_data(self, id: int, data: str, msgFlag=canlib.canMSG_STD):
        #CAN 메시지 보내기
        frame = Frame(id_ = id, data= data, flags=msgFlag)
        try:
            self.ch.write(frame)
        except canlib.exceptions.CanGeneralError as e:
            print(f"Error transmitting data: {e}")

    def __iter__(self):
        while True:
            try:
                frame = self.ch.read()
                yield frame
            except canlib.canNoMsg:
                yield 0
            except canlib.canError:
                return

    def tearDownChannel(self):
        self.ch.busOff()
        self.ch.close()

def split_data_into_chunks(data, chunk_size=8):
    #큰 데이터를 CAN 전송을 위해 분할하기
    chunks = []
    total_chunks = (len(data) + chunk_size - 1) // chunk_size
    for i in range(total_chunks):
        chunk = data[i*chunk_size :(i+1)*chunk_size]
        chunks.append(chunk)
    return chunks

def transmit():
    transmitter = Kvaser()

    try:
        while True:
            data = input("Enter data to trasmit: ")
            data_type = bytearray(data, 'utf-8')
            chunks = split_data_into_chunks(data_type, chunk_size=8)
            for chunk in chunks:
                transmitter.transmit_data(0x123, chunk)
                print(f"Transmitted chunk: {chunk}")
                time.sleep(0.2)

    except KeyboardInterrupt:
        print("Transmission stopped by user.")
    finally:
        del transmitter

def receive():
    receiver = Kvaser()
    try:
        while True:
            frame = receiver.read(id=0x123)
            if frame:
                print(f"Received data: {frame.data}")
            else:
                print("No data received")
    except KeyboardInterrupt:
        print("interrupt received. shutting down.")
    finally:
        del receiver

def main():
    pass
  #kvaser 활용하여 CAN 전송 혹은 읽기 작성

if __name__ == "__main__":
    transmit()
```   

## 위에 실습에서 can driver 사용하기

✅ CAN 통신 세팅 :  p.117 따라하기   
   
✅ kvaser_base.py   
![11123](https://github.com/user-attachments/assets/b45c12e4-e348-473b-bb4e-dedc9025ddb4)   
![1112](https://github.com/user-attachments/assets/00df99d5-1dc8-455f-b3ec-7fa1a8062de9)   

## 파일 추가되면 자동전송

