---
layout: single
title:  "OTA"
categories: autoever
tag: 
author_profile: false #true면 글 안에서 내 프로필 보여줌
sidebar:
    nav: "counts"
#search: false
---

# 느낀점


# OTA 개요

## 과정

ota 는 다운로드와 설치 단계가 있다. 다운로드는 주행중해도되지만 설치는 주차돼있을때 해야한다.   

sota: 쉬움   
   
fota: 하드웨어를 다룰 수 있는 low level control 을 할 수 있다.   

centralized architecture: 이 아키텍처가 표준화되어야한다.   

```c
수직 구성

OTA Server : DM(Download Management) Master  
ㅣ
ㅣ<Wireless Comm. lte. 얘만 무선>
ㅣ

DCU (Modem) : 서버와 무선통신 수행(LTE, WiFi, WAVE, etc)
ㅣ
ㅣ<In-Vehicle Network, 여기서부턴 유선>
ㅣ
Master ECU : DM Client 및 OTA Master 를 포함.
버전 체크, 무선 다운로드, 리프로그래밍 수행
ROM file 관리, OTA 우선순위 판단 등을 수행
ㅣ
ㅣ
ㅣ
Target ECU
```
   
✅ ECU 엔 업데이트 영역과 작동 영역으로 a,b 두 개로 나눠진다.   
<img src="https://github.com/user-attachments/assets/d9c42c29-e48d-45ae-a473-1a8e377187bf" width="900" height="330">   

## TUF

freshness 라는게 차이가 나는 속성이 있다. 이유에 대해서 한번 다시 보자.   

# 실습

## 서버세팅

책에 나와있는대로 세팅하고, <https://mosquitto.org/download/> 에 들어가서 mosquitto-64 로 다운받으면된다.   
   
```c
1. 라즈베리파이세팅
2. C:/programs에 있는 mosquito 를 우클릭하여 cmd 로 열기 한다.
3. 라즈베리파이를 broker 로 만들거다.
4. 가상환경 세팅을 했던거같다.
5. 라즈베리파이 업데이트를 한다.

이후는 책을 따라한다.
```

## mosquitto broker pub1, sub2 개

아 그리고 우선 vim 설치도 하고 세팅도했다.(구글링 고고)   
✅ putty 로 pubisher 1개, sub 2개를 설정했다.   
<img src="https://github.com/user-attachments/assets/e25477db-f07e-4a7b-810b-2794480ac58c" width="900" height="640">   

# 실습

## 서버에서 매번 같은 메세지를 발생시키게하기

p.96의 그림을 참고하면된다. 

새로운 폴더를 만들고 그 안에 py 파일을 하나 새로 만들었다.   

```c
pip install paho-mqtt
```

아래의 코드를 실행하면 server에서 동작하는거고, 보낸 메세지는 브로커 하나를 통해 subscriber 에게 간다.   
✅ publisher_message.py   
```python
import paho.mqtt.client as mqtt

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("Connected to broker")
    else:
        printf(f"Connection failed with code {rc}")

def on_disconnect(client, usedata, rc):
    print("Disconnected from broker, code:", rc)

def on_publish(client, userdata, mid):
    print(f"Message {mid} published successfully")

def send_message_to_broker(message, broker_ip, username, password, port=1883):
    client = mqtt.Client()

    client.on_connect = on_connect
    client.on_disconnect = on_disconnect
    client.on_publish = on_publish

    client.username_pw_set(username, password)

    client.connect(broker_ip, port=port)

    client.loop_start()

    client.publish(topic, message)

    client.loop_stop()
    client.disconnect()

if __name__ == "__main__":
    topic = 'message'
    broker_ip = '192.168.137.171'
    username = input("Enter username: ")
    password = input("Enter password: ")
    message = input("Enter message to publish: ")
    send_message_to_broker(message, broker_ip, username, password)
```   
![1234](https://github.com/user-attachments/assets/18c1a32e-b8df-4f01-a4f9-a80a6fe0d964)   

## 서버에서 실행하면 tier 에 따라 차등 기능 제공

✅ publish_message_id_tier.py   
```python
import paho.mqtt.client as mqtt
import json
import os

status = 'login'

def change_status(new_status):
    global status
    status = new_status

def on_connect(client, userdata, flags, rc):
    pass

def on_disconnect(client, userdata, rc):
    pass

def on_publish(client, userdata, mid):
    print("Message published with mid: " + str(mid))

def main():
    global status
    broker_ip = '192.168.137.171'
    client = mqtt.Client()
    client.on_connect = on_connect
    client.on_disconnect = on_disconnect
    client.on_publish = on_publish
    change_status('login')

    # Load user data from pwfile.json
    with open(os.path.join(os.path.dirname(os.path.abspath(__file__)),'pwfile.json'), 'r') as f:
        user_data = json.load(f)

    # Load topic data from topic_tier_list.json
    with open(os.path.join(os.path.dirname(os.path.abspath(__file__)),'topic_tier_list.json'), 'r') as f:
        topic_data = json.load(f)

    while status == 'login':
        username = input("Enter username: ")
        password = input("Enter password: ")

        # Validate username and password
        if username in user_data and user_data[username]["pw"] == password:
            user_tier = user_data[username]["Tier"]
            print(f"Login successful. Your Tier: {user_tier}")
        else:
            print("Invalid username or password.")
            continue

        client.username_pw_set(username, password)
        client.connect(broker_ip, port=1883)
        client.loop_start()

        change_status('topic')

        while status == 'topic':
            tier_key = f"Tier-{user_tier}"
            if tier_key in topic_data:
                print("Available topics:")
                for idx, topic in enumerate(topic_data[tier_key]["topics"], start=1):
                    print(f"{idx}: {topic}")
            else:
                print(f"No topics available for Tier-{user_tier}.")
                continue

            topic_idx = input("Enter topic number: ")

            # Validate topic selection
            try:
                topic_idx = int(topic_idx) - 1
                if 0 <= topic_idx < len(topic_data[tier_key]["topics"]):
                    topic = topic_data[tier_key]["topics"][topic_idx]
                    change_status('message')
                else:
                    print("Invalid topic number.")
                    continue
            except ValueError:
                print("Invalid input. Please enter a number.")
                continue

            while status == 'message':
                message = input(f"Enter message to publish {topic}: ")
                client.publish(topic, message)
                client.loop_stop()

if __name__ == "__main__":
    main()
```   
![스크린샷 2025-04-18 164555](https://github.com/user-attachments/assets/eeef62d8-e20e-4583-803a-5d1e449d5375)   

## 서버가 subscriber 가 되기

```python
import paho.mqtt.client as mqtt
import os

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("Connected to MQTT Broker!")
    
    elif rc == 5:
        print("Connection refused: not authorized")
    
    else:
        print("Connection failed with code:", rc)

def on_disconnect(client, userdata, rc):
    if rc == 0:
        print("Disconnected from MQTT Broker!")
    elif rc ==5:
        username = input("Enter username: ")
        password = input("Enter password: ")
        client.username_pw_set(username, password)
    elif rc !=0:
        print("Unexpected disconnection with code:", rc)

def on_message(client, userdata, msg):
    try:
        payload = msg.payload.decode()
        print(f"Received message '{payload}' on topic '{msg.topic}'")
    except Exception as e:
        print(f"Error decoding message: {e}")

def receive_message_to_broker(broker_ip, username, password, topic, port=1883):
    client = mqtt.Client()
    
    client.on_connect = on_connect
    client.on_disconnect = on_disconnect
    client.on_message = on_message

    client.username_pw_set(username, password)

    client.connect(broker_ip, port=port)

    client.subscribe(topic)
    print(f"Subscribed to topic '{topic}'")
    client.loop_forever()


if __name__ == "__main__":
    broker_ip = "192.168.137.171"
    topic = "topic"
    username = input("Enter username: ")
    password = input("Enter password: ")
    receive_message_to_broker(broker_ip, username, password, topic)
```   
   
![sub](https://github.com/user-attachments/assets/be1cb1e0-0e00-4316-80bd-98b5523012f6)   

## 
## 전선 연결해서 CAN 통신

✅ kvaser_base.py   
컴퓨터에서 라즈베리파이로 캔통신으로 보내기.   
![스크린샷 2025-04-21 140852](https://github.com/user-attachments/assets/68486c93-d49a-4d9a-841d-c34e6edfc397)   
통신이 되면 위의 사진처럼 뭐가 뜬다.
```python
from canlib import canlib, Frame
import time

# Kvaser 연결 및 설정 class
class Kvaser:
    def __init__(self, channel=0):
        self.channel = channel
        self.openFlags = canlib.canOPEN_ACCEPT_VIRTUAL
        self.bitrate = canlib.canBITRATE_125K
        self.bitrateFlags = canlib.canDRIVER_NORMAL

        self.valid = False
        self.ch = None
        self.device_name = ''
        self.card_upc_no = ''
        try:
            self.ch = canlib.openChannel(self.channel, self.openFlags)
            self.ch.setBusOutputControl(self.bitrateFlags)
            self.ch.setBusParams(self.bitrate)
            self.ch.iocontrol.timer_scale = 1
            self.ch.iocontrol.local_txecho = True
            self.ch.busOn()
            self.valid = True
            self.device_name = canlib.ChannelData.channel_name
            self.card_upc_no = canlib.ChannelData(self.channel).card_upc_no
        except canlib.exceptions.CanGeneralError as e:
            print(f"Error initializing Kvaser channel: {e}")
            self.valid = False
            self.ch = None

    def __del__(self):
        if self.ch:
            self.tearDownChannel()


    def read(self, id, timeout_ms=-1): #CAN read 대기시간
        #CAN 메시지를 읽도록 작성
        try:
            result = self.ch.read(timeout=timeout_ms)
            if result.id == id:
                return result
        except canlib.canNoMsg:
            print("No message received")

        except canlib.canError as e:
            print(f"Error reading from Kvaser channel: {e}")
        return None

    def mkdata(self, data):
        #데이터 형태를 CAN에 적합하도록 변경
        pass
      
    def transmit_data(self, id: int, data: str, msgFlag=canlib.canMSG_STD):
        #CAN 메시지 보내기
        frame = Frame(id_ = id, data= data, flags=msgFlag)
        try:
            self.ch.write(frame)
        except canlib.exceptions.CanGeneralError as e:
            print(f"Error transmitting data: {e}")

    def __iter__(self):
        while True:
            try:
                frame = self.ch.read()
                yield frame
            except canlib.canNoMsg:
                yield 0
            except canlib.canError:
                return

    def tearDownChannel(self):
        self.ch.busOff()
        self.ch.close()

def split_data_into_chunks(data, chunk_size=8):
    #큰 데이터를 CAN 전송을 위해 분할하기
    chunks = []
    total_chunks = (len(data) + chunk_size - 1) // chunk_size
    for i in range(total_chunks):
        chunk = data[i*chunk_size :(i+1)*chunk_size]
        chunks.append(chunk)
    return chunks

def transmit():
    transmitter = Kvaser()

    try:
        while True:
            data = input("Enter data to trasmit: ")
            data_type = bytearray(data, 'utf-8')
            chunks = split_data_into_chunks(data_type, chunk_size=8)
            for chunk in chunks:
                transmitter.transmit_data(0x123, chunk)
                print(f"Transmitted chunk: {chunk}")
                time.sleep(0.2)

    except KeyboardInterrupt:
        print("Transmission stopped by user.")
    finally:
        del transmitter

def receive():
    receiver = Kvaser()
    try:
        while True:
            frame = receiver.read(id=0x123)
            if frame:
                print(f"Received data: {frame.data}")
            else:
                print("No data received")
    except KeyboardInterrupt:
        print("interrupt received. shutting down.")
    finally:
        del receiver

def main():
    pass
  #kvaser 활용하여 CAN 전송 혹은 읽기 작성

if __name__ == "__main__":
    transmit()
```   

## 위에 실습에서 can driver 사용하기

✅ CAN 통신 세팅 :  p.117 따라하기   
   
✅ kvaser_base.py   
![11123](https://github.com/user-attachments/assets/b45c12e4-e348-473b-bb4e-dedc9025ddb4)   
![1112](https://github.com/user-attachments/assets/00df99d5-1dc8-455f-b3ec-7fa1a8062de9)   

## pub(내컴퓨터) -> broker 통해서 -> sub(내컴퓨터)

✅ 작동방식   
1. subscribe_file.py 를 cmd 에서 실행   
2. publish_file.py 를 cmd 에서 실행   
3. publish_file.py cmd 창에서 전송할 파일 이름 입력 (절대경로도 ok)   
4. sub에서 잘 받았다 메세지 뜰거임   
5. 같은 위치의 tmp 파일에 저장됐는지 확인   
   
✅ 결과   
![12](https://github.com/user-attachments/assets/9aabfd34-3981-4016-ba18-fe5592de06e3)   
![13](https://github.com/user-attachments/assets/fd95e7b6-abef-4f44-8671-1bcd6a443830)   
![14](https://github.com/user-attachments/assets/e9361ac5-6e03-4412-b27a-6ff5a1bf4c13)   
   
✅ 코드   
publish_file.py   
```python
import paho.mqtt.client as mqtt
import os
import base64

name_topic = "updates/name"
file_topic = "updates/file"
broker_ip = "192.168.137.171"

def make_message(file_path):
    try:
        with open(file_path, "rb") as file:
            file_data = file.read()
            message = base64.b64encode(file_data).decode('utf-8')
            return message
    except FileNotFoundError as e:
        print(f"File not found: {file_path}")
        raise

def send_file_to_broker(publish_file, broker_ip, username, password, port=1883):
    client = mqtt.Client()

    client.on_connect = on_connect
    client.on_disconnect = on_disconnect    
    client.on_publish = on_publish

    try:
        client.username_pw_set(username, password)
        client.connect(broker_ip, port=port)

        message = make_message(publish_file)
        file_name = os.path.basename(publish_file)

        print(file_name)
        #print(message)
        
        client.loop_start()
        client.publish(name_topic, file_name, qos=2)
        client.publish(file_topic, message, qos=2)
        client.loop_stop()

        print(f"Success sending file(updates/name): {file_name}")
        print(f"Success sending file(updates/file)")
        
        client.disconnect()
    except FileNotFoundError as e:
        print(f"File not found: {publish_file}")
    except Exception as e:
        print(f"An error occurred: {e}")


def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("Connected to MQTT Broker!")
    else:
        print("Connection failed with code:", rc)

def on_disconnect(client, userdata, rc):
    print("Disconnected from MQTT Broker with code:", rc)   

def on_publish(client, userdata, mid):
    print("Message published with ID:", mid)

if __name__ == "__main__":
    username = input("Enter username: ")
    password = input("Enter password: ")
    file_path = input("Enter the path of the file to send: ")
    send_file_to_broker(file_path, broker_ip, username, password) 
```
   
subscribe.py   
```python
import paho.mqtt.client as mqtt
import os
import base64

topic = "topic"
name_topic = "updates/name"
file_topic = "updates/file"
broker_ip = "192.168.137.171"

tmp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'tmp')
os.makedirs(tmp_dir, exist_ok=True)

file_name = None
file_data = None

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("Connected to broker")
    elif rc == 5:
        print("Connection refused : not authorized")
    else:
        print(f"Connection failed with code: {rc}")

def on_disconnect(client, userdata, rc):
    if rc == 0:
        print(f"Disconnected from broker, code: {rc}")
    elif rc != 0:
        print(f'Unexpected disconnection: {rc}')

def on_message(client, userdata, msg):
    global file_name, file_data
    try:
        payload = msg.payload.decode('utf-8')
        topic = msg.topic

        if topic == name_topic:
            file_name =  payload
        elif topic == file_topic:
            file_data = base64.b64decode(payload)


        print(f"MSG RECEIVED ON TOPIC; {msg.topic}: {msg.payload}")
    except Exception as e:
        print(f"ERROR: DECODING MSG {e}")

    if file_name and file_data:
        file_path = os.path.join(tmp_dir, file_name)
        with open(file_path, 'wb') as f:
            f.write(file_data)
        print(f"FILE RECEIVED as {file_name}")
        file_name = None
        file_data = None

def receive_message_to_broker(broker_ip, username, password, port=1883):
    client = mqtt.Client()

    client.on_connect = on_connect
    client.on_disconnect = on_disconnect
    client.on_message = on_message

    client.username_pw_set(username, password)

    client.connect(broker_ip, port=port)
    
    client.subscribe(name_topic)
    client.subscribe(file_topic)
    print(f"SUBSCRIBED TOPIC : {name_topic}")
    print(f"SUBSCRIBED TOPIC : {file_topic}")
    client.loop_forever()

if __name__ == "__main__":

    broker_ip = '192.168.137.171'
    username = 'qqqq'
    password = '1111'

    receive_message_to_broker(broker_ip, username, password)
```

## 노트북과 노트북끼리 can 통신

✅ 결과   
![123123](https://github.com/user-attachments/assets/74469f70-ce9e-498b-b47e-114330f9659b)   
   
✅ kvase_can_transmitter.py   
```python
from canlib import canlib, Frame
import time
import os

# Kvaser 연결 및 설정 class
class Kvaser:
    def __init__(self, channel=0):
        self.channel = channel
        self.openFlags = canlib.canOPEN_ACCEPT_VIRTUAL
        self.bitrate = canlib.canBITRATE_125K
        self.bitrateFlags = canlib.canDRIVER_NORMAL

        self.valid = False
        self.ch = None
        self.device_name = ''
        self.card_upc_no = ''
        try:
            self.ch = canlib.openChannel(self.channel, self.openFlags)
            self.ch.setBusOutputControl(self.bitrateFlags)
            self.ch.setBusParams(self.bitrate)
            self.ch.iocontrol.timer_scale = 1
            self.ch.iocontrol.local_txecho = True
            self.ch.busOn()
            self.valid = True
            self.device_name = canlib.ChannelData.channel_name
            self.card_upc_no = canlib.ChannelData(self.channel).card_upc_no
        except canlib.exceptions.CanGeneralError as e:
            print(f"Error initializing Kvaser channel: {e}")
            self.valid = False
            self.ch = None

    def __del__(self):
        if self.ch:
            self.tearDownChannel()


    def read(self, id, timeout_ms=-1): #CAN read 대기시간
        #CAN 메시지를 읽도록 작성
        try:
            result = self.ch.read(timeout=timeout_ms)
            if result.id == id:
                return result
        except canlib.canNoMsg:
            print("No message received")

        except canlib.canError as e:
            print(f"Error reading from Kvaser channel: {e}")
        return None

    def mkdata(self, data):
        #데이터 형태를 CAN에 적합하도록 변경
        pass
      
    def transmit_data(self, id: int, data: str, msgFlag=canlib.canMSG_STD):
        #CAN 메시지 보내기
        frame = Frame(id_ = id, data= data, flags=msgFlag)
        try:
            self.ch.write(frame)
        except canlib.exceptions.CanGeneralError as e:
            print(f"Error transmitting data: {e}")

    def __iter__(self):
        while True:
            try:
                frame = self.ch.read()
                yield frame
            except canlib.canNoMsg:
                yield 0
            except canlib.canError:
                return

    def tearDownChannel(self):
        self.ch.busOff()
        self.ch.close()

def split_data_into_chunks(data, chunk_size=8):
    #큰 데이터를 CAN 전송을 위해 분할하기
    chunks = []
    total_chunks = (len(data) + chunk_size - 1) // chunk_size
    
    chunks.append(bytearray(b'\x00\xff\x00\xff\x00\xff\x00\xff'))  # start of transmission marker
    for i in range(total_chunks):
        chunk = data[i*chunk_size :(i+1)*chunk_size]
        chunks.append(chunk)
    chunks.append(bytearray(b'\x00\xff\x00\xff\x00\xff\x00\xff'))  # End of transmission marker
    return chunks

def send_file():
    transmitter = Kvaser()

    try:
        while True:
            file_path = input("Enter the file path to send (or 'exit' to quit): ")
            
            with open(file_path, 'rb') as file:
                file_data = file.read()
                file_name = os.path.basename(file_path)

                data = file_name.encode('utf-8')+b':'+file_data
            
                chunks = split_data_into_chunks(data)

                for chunk in chunks:
                    transmitter.transmit_data(0x123, chunk)
                    print(f"Transmitted chunk: {chunk}")
                    time.sleep(0.2)

    except KeyboardInterrupt:
        print("Transmission stopped by user.")

    except FileNotFoundError as e:
        print(f"File not found: {e}")
    
    except canlib.canError as e:
        print(f"Error during transmission: {e}")
    
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

    finally:
        del transmitter

def receive():
    receiver = Kvaser()
    try:
        while True:
            frame = receiver.read(id=0x123)
            if frame:
                print(f"Received data: {frame.data}")
            else:
                print("No data received")
    except KeyboardInterrupt:
        print("interrupt received. shutting down.")
    finally:
        del receiver

def main():
    pass
  #kvaser 활용하여 CAN 전송 혹은 읽기 작성

if __name__ == "__main__":
    #receive()
    send_file()
```
한쪽은 receive 다른 쪽은 transmit 을 하면된다. can 짹으로 둘 다 연결하면 된다.   

## 라즈베리파이 실행하면 자동으로 application 띄우기

![KakaoTalk_20250421_182822491](https://github.com/user-attachments/assets/43c7b8ba-56a8-43df-b261-0a1c0ee1e74b)

```c
1. 라즈베리파이에서
$mkdir ~/.config/autostart 수행후
$vi ~/.config/autostart/ui.desktop
해서

[Desktop Entry]
Type = Application
Name = Backdoor GUI
Exec = sudo python3 /home/user/OTA/ui_base.py
X-GNOME-Autostart-enabled=true

2. 라즈베리파이에서
$ mkdir OTA
$ vi ui_base.py
해서 아래의 파일을 복풋한다.

import tkinter as tk
import subprocess

def button_click(btn_id):
    pass
    
def exit_program():
    print("프로그램 종료")
    root.quit()

# 풀스크린 GUI 설정
root = tk.Tk()
root.title("실습용 라즈베리 파이 UI")
root.attributes("-fullscreen", True)

# 버튼들
btn1 = tk.Button(root, text="Button 1", command=lambda: button_click('btn1'), height=3, width=20)
btn2 = tk.Button(root, text="Button 2", command=lambda: button_click('btn2'), height=3, width=20)
btn3 = tk.Button(root, text="Button 3", command=lambda: button_click('btn3'), height=3, width=20)

# 종료 버튼 (처음엔 숨겨짐)
exit_btn = tk.Button(root, text="종료", command=exit_program, height=2, width=10, bg='red', fg='white')
exit_btn.pack_forget()  # 처음엔 숨기기

btn1.pack(pady=20)
btn2.pack(pady=20)
btn3.pack(pady=20)
exit_btn.pack()
root.mainloop()
```

## AES

```python
import os
import hashlib
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.padding import PKCS7
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization, hashes

def encrypt_file_aes(file_data, aes_key):
    block_size = algorithms.AES.block_size

    padder = PKCS7(block_size).padder()
    padded_data = padder.update(file_data) + padder.finalize()

    iv = os.urandom(16)
    cipher = Cipher(algorithms.AES(aes_key),modes.CBC(iv), backend = default_backend())
    encryptor = cipher.encryptor()
    cipher_text = encryptor.update(padded_data) + encryptor.finalize()
    return iv, cipher_text

def decrypt_file_aes(cipher_text, aes_key, iv):
    block_size = algorithms.AES.block_size

    try:
        cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), default_backend())
        decryptor = cipher.decryptor()
        padded_data = decryptor.update(cipher_text) + decryptor.finalize()

        unpadder = PKCS7(block_size).unpadder()
        decrypted_text = unpadder.update(padded_data) + unpadder.finalize()
        return decrypted_text
    
    except Exception as e:
        raise ValueError(f'Decryption failed: {e}')

def rsa_key_generation():
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=4096
    )
    public_key = private_key.public_key()

    private_pem = private_key.private_bytes(
        encoding = serialization.Encoding.PEM,
        format = serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm = serialization.BestAvailableEncryption(b'private')
    )

    public_pem = public_key.public_bytes(
        encoding = serialization.Encoding.PEM,
        format = serialization.PublicFormat.SubjectPublicKeyInfo
    )

    key_path = os.path.join(os.getcwd(), 'key')
    os.makedirs(key_path, exist_ok= True)

    private_key_path = os.path.join(key_path, "Private_key1.pem")
    with open(private_key_path, 'wb') as key_file:
        key_file.write(private_pem)

    public_key_path = os.path.join(key_path, "Public_key1.pem")
    with open(public_key_path, 'wb') as key_file:
        key_file.write(public_pem)

def encrypt_file_rsa(file_data, public_key_path):
    with open(public_key_path, 'rb') as key_file:
        public_key = serialization.load_pem_public_key(
            key_file.read(),
            backend = default_backend()
        )
    encrypted_file = public_key.encrypt(
        file_data,
        padding.OAEP(
            mgf = padding.MGF1(algorithm = hashes.SHA256()),
            algorithm = hashes.SHA256(),
            label = None
        )
    )
    return encrypted_file

def decrypt_file_rsa(encrypted_data, private_key_path):
    with open(private_key_path, 'rb') as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password = b'private',
            backend = default_backend()
        )
    decrypted_file = private_key.decrypt(
        encrypted_data,
        padding.OAEP(
            mgf = padding.MGF1(algorithm = hashes.SHA256()),
            algorithm = hashes.SHA256(),
            label = None
            )
        )
    return decrypted_file

def compute_file_hash(file_path):
    sha256_hash = hashlib.sha256()
    with open(file_path, 'rb') as file:
        for chunk in iter(lambda: file.read(4096), b""):
            sha256_hash.update(chunk)
    return sha256_hash.hexdigest()

def sign_file(file_data, private_key_path):
    with open(private_key_path, 'rb') as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password = b'private',
            backend = default_backend()
        )

    signature = private_key.sign(
        file_data,
        padding.PSS(
            mgf = padding.MGF1(hashes.SHA256()),
            salt_length = padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    return signature

def verify_sign(signature, file_data, public_key_path):
    with open(public_key_path, 'rb') as key_file:
        public_key = serialization.load_pem_public_key(
            key_file.read(),
            backend = default_backend()
        )
    try:
        public_key.verify(
            signature,
            file_data,
            padding.PSS(
                mgf = padding.MGF1(hashes.SHA256()),
                salt_length = padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return True
    
    except Exception:
        return False
def main():
    aes_key = os.urandom(32)
    print('AES key: ', aes_key)
    with open("C:/Users/user/Desktop/Autoever/실습/test.txt", 'rb') as file:
        file_data = file.read()
    print('Plain text: ', file_data)

    iv, encrypted_text = encrypt_file_aes(file_data, aes_key)
    print('AES Encrypted text: ', encrypted_text)

    decrypted_text = decrypt_file_aes(encrypted_text, aes_key, iv)
    print('AES Decrypted text: ', decrypted_text)

    rsa_encrypted_file =  encrypt_file_rsa(file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Public_key.pem")
    print('RSA Encrypted text: ', rsa_encrypted_file)

    rsa_decrypted_file = decrypt_file_rsa(rsa_encrypted_file, "C:/Users/user/Desktop/Autoever/실습/Key/Private_key.pem")
    print('RSA Decrypted text: ', rsa_decrypted_file)
    file_hash = compute_file_hash("C:/Users/user/Desktop/Autoever/실습/test.txt")
    print("File hash: ", file_hash)

    signature = sign_file(file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Private_key.pem")
    print('Signature of the file: ', signature)

    if verify_sign(signature, file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Public_key.pem"):
        print('Verify success')
    else:
        print('verify failed')

if __name__ == "__main__":
    aes_key = os.urandom(32)
    print('AES key: ', aes_key)
    with open("hello.txt", 'rb') as file:
        file_data = file.read()
    print('Plain test: ', file_data)

    iv, encrypt_file_data = encrypt_file_aes(file_data, aes_key)
    print('AES Encrypted text: ', encrypt_file_data)

    decrypt_file_data = decrypt_file_aes(encrypt_file_data, aes_key, iv)
    print('AES Decrypted text: ', decrypt_file_data)
```   
   
![AES](https://github.com/user-attachments/assets/737c627b-985c-4186-8637-d6b23a4d4f9f)   

## RSA

위의 코드에서 main 전부 주석처리하고 rsa_key_generation() 을 해주면 된다. 
그럼 key 폴더가 생기고 key 가 생성된다. 그럼 rsa 키를 사용해서 data 키를 암복호화할것이다.   

rsa 와 aes 비교   
![rsaaes](https://github.com/user-attachments/assets/a32d586e-2e1c-45a4-b2a0-5ce7de054322)   
rsa 가 훨씬 긴 것을 볼 수 있다.   
```python
import os
import hashlib
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.padding import PKCS7
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization, hashes

def encrypt_file_aes(file_data, aes_key):
    block_size = algorithms.AES.block_size

    padder = PKCS7(block_size).padder()
    padded_data = padder.update(file_data) + padder.finalize()

    iv = os.urandom(16)
    cipher = Cipher(algorithms.AES(aes_key),modes.CBC(iv), backend = default_backend())
    encryptor = cipher.encryptor()
    cipher_text = encryptor.update(padded_data) + encryptor.finalize()
    return iv, cipher_text

def decrypt_file_aes(cipher_text, aes_key, iv):
    block_size = algorithms.AES.block_size

    try:
        cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), default_backend())
        decryptor = cipher.decryptor()
        padded_data = decryptor.update(cipher_text) + decryptor.finalize()

        unpadder = PKCS7(block_size).unpadder()
        decrypted_text = unpadder.update(padded_data) + unpadder.finalize()
        return decrypted_text
    
    except Exception as e:
        raise ValueError(f'Decryption failed: {e}')

def rsa_key_generation():
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=4096
    )
    public_key = private_key.public_key()

    private_pem = private_key.private_bytes(
        encoding = serialization.Encoding.PEM,
        format = serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm = serialization.BestAvailableEncryption(b'private')
    )

    public_pem = public_key.public_bytes(
        encoding = serialization.Encoding.PEM,
        format = serialization.PublicFormat.SubjectPublicKeyInfo
    )

    key_path = os.path.join(os.getcwd(), 'key')
    os.makedirs(key_path, exist_ok= True)

    private_key_path = os.path.join(key_path, "Private_key1.pem")
    with open(private_key_path, 'wb') as key_file:
        key_file.write(private_pem)

    public_key_path = os.path.join(key_path, "Public_key1.pem")
    with open(public_key_path, 'wb') as key_file:
        key_file.write(public_pem)

def encrypt_file_rsa(file_data, public_key_path):
    with open(public_key_path, 'rb') as key_file:
        public_key = serialization.load_pem_public_key(
            key_file.read(),
            backend = default_backend()
        )
    encrypted_file = public_key.encrypt(
        file_data,
        padding.OAEP(
            mgf = padding.MGF1(algorithm = hashes.SHA256()),
            algorithm = hashes.SHA256(),
            label = None
        )
    )
    return encrypted_file

def decrypt_file_rsa(encrypted_data, private_key_path, password = b'private'):
    with open(private_key_path, 'rb') as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password = password,
            backend = default_backend()
        )
    decrypted_file = private_key.decrypt(
        encrypted_data,
        padding.OAEP(
            mgf = padding.MGF1(algorithm = hashes.SHA256()),
            algorithm = hashes.SHA256(),
            label = None
            )
        )
    return decrypted_file

def compute_file_hash(file_path):
    sha256_hash = hashlib.sha256()
    with open(file_path, 'rb') as file:
        for chunk in iter(lambda: file.read(4096), b""):
            sha256_hash.update(chunk)
    return sha256_hash.hexdigest()

def sign_file(file_data, private_key_path):
    with open(private_key_path, 'rb') as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password = b'private',
            backend = default_backend()
        )

    signature = private_key.sign(
        file_data,
        padding.PSS(
            mgf = padding.MGF1(hashes.SHA256()),
            salt_length = padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    return signature

def verify_sign(signature, file_data, public_key_path):
    with open(public_key_path, 'rb') as key_file:
        public_key = serialization.load_pem_public_key(
            key_file.read(),
            backend = default_backend()
        )
    try:
        public_key.verify(
            signature,
            file_data,
            padding.PSS(
                mgf = padding.MGF1(hashes.SHA256()),
                salt_length = padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return True
    
    except Exception:
        return False
def main():
    aes_key = os.urandom(32)
    print('AES key: ', aes_key)
    with open("C:/Users/user/Desktop/Autoever/실습/test.txt", 'rb') as file:
        file_data = file.read()
    print('Plain text: ', file_data)

    iv, encrypted_text = encrypt_file_aes(file_data, aes_key)
    print('AES Encrypted text: ', encrypted_text)

    decrypted_text = decrypt_file_aes(encrypted_text, aes_key, iv)
    print('AES Decrypted text: ', decrypted_text)

    rsa_encrypted_file =  encrypt_file_rsa(file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Public_key.pem")
    print('RSA Encrypted text: ', rsa_encrypted_file)

    rsa_decrypted_file = decrypt_file_rsa(rsa_encrypted_file, "C:/Users/user/Desktop/Autoever/실습/Key/Private_key.pem")
    print('RSA Decrypted text: ', rsa_decrypted_file)
    file_hash = compute_file_hash("C:/Users/user/Desktop/Autoever/실습/test.txt")
    print("File hash: ", file_hash)

    signature = sign_file(file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Private_key.pem")
    print('Signature of the file: ', signature)

    if verify_sign(signature, file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Public_key.pem"):
        print('Verify success')
    else:
        print('verify failed')

if __name__ == "__main__":
    aes_key = os.urandom(32)
    print('AES key: ', aes_key)
    with open("hello.txt", 'rb') as file:
        file_data = file.read()
    print('Plain test: ', file_data)

    # iv, encrypt_file_data = encrypt_file_aes(file_data, aes_key)
    # print('AES Encrypted text: ', encrypt_file_data)

    # decrypt_file_data = decrypt_file_aes(encrypt_file_data, aes_key, iv)
    # print('AES Decrypted text: ', decrypt_file_data)

    encrypt_file_data = encrypt_file_rsa(file_data, "key/Public_key1.pem")
    print("RSA Encrypted text: ", encrypt_file_data)

    decrypt_file_data = decrypt_file_rsa(encrypt_file_data, "key/Private_key1.pem")
    print("RSA Decrypted text: ", decrypt_file_data)
```

## rsa 로 검증된 키인지 아닌지에따라 출력 다르게

```python
import os
import hashlib
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.padding import PKCS7
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization, hashes

def encrypt_file_aes(file_data, aes_key):
    block_size = algorithms.AES.block_size

    padder = PKCS7(block_size).padder()
    padded_data = padder.update(file_data) + padder.finalize()

    iv = os.urandom(16)
    cipher = Cipher(algorithms.AES(aes_key),modes.CBC(iv), backend = default_backend())
    encryptor = cipher.encryptor()
    cipher_text = encryptor.update(padded_data) + encryptor.finalize()
    return iv, cipher_text

def decrypt_file_aes(cipher_text, aes_key, iv):
    block_size = algorithms.AES.block_size

    try:
        cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), default_backend())
        decryptor = cipher.decryptor()
        padded_data = decryptor.update(cipher_text) + decryptor.finalize()

        unpadder = PKCS7(block_size).unpadder()
        decrypted_text = unpadder.update(padded_data) + unpadder.finalize()
        return decrypted_text
    
    except Exception as e:
        raise ValueError(f'Decryption failed: {e}')

def rsa_key_generation():
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=4096
    )
    public_key = private_key.public_key()

    private_pem = private_key.private_bytes(
        encoding = serialization.Encoding.PEM,
        format = serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm = serialization.BestAvailableEncryption(b'private')
    )

    public_pem = public_key.public_bytes(
        encoding = serialization.Encoding.PEM,
        format = serialization.PublicFormat.SubjectPublicKeyInfo
    )

    key_path = os.path.join(os.getcwd(), 'key')
    os.makedirs(key_path, exist_ok= True)

    private_key_path = os.path.join(key_path, "Private_key1.pem")
    with open(private_key_path, 'wb') as key_file:
        key_file.write(private_pem)

    public_key_path = os.path.join(key_path, "Public_key1.pem")
    with open(public_key_path, 'wb') as key_file:
        key_file.write(public_pem)

def encrypt_file_rsa(file_data, public_key_path):
    with open(public_key_path, 'rb') as key_file:
        public_key = serialization.load_pem_public_key(
            key_file.read(),
            backend = default_backend()
        )
    encrypted_file = public_key.encrypt(
        file_data,
        padding.OAEP(
            mgf = padding.MGF1(algorithm = hashes.SHA256()),
            algorithm = hashes.SHA256(),
            label = None
        )
    )
    return encrypted_file

def decrypt_file_rsa(encrypted_data, private_key_path, password = b'private'):
    with open(private_key_path, 'rb') as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password = password,
            backend = default_backend()
        )
    decrypted_file = private_key.decrypt(
        encrypted_data,
        padding.OAEP(
            mgf = padding.MGF1(algorithm = hashes.SHA256()),
            algorithm = hashes.SHA256(),
            label = None
            )
        )
    return decrypted_file

def compute_file_hash(file_path):
    sha256_hash = hashlib.sha256()
    with open(file_path, 'rb') as file:
        for chunk in iter(lambda: file.read(4096), b""):
            sha256_hash.update(chunk)
    return sha256_hash.hexdigest()

def sign_file(file_data, private_key_path, password = b'private'):
    with open(private_key_path, 'rb') as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password = password,
            backend = default_backend()
        )

    signature = private_key.sign(
        file_data,
        padding.PSS(
            mgf = padding.MGF1(hashes.SHA256()),
            salt_length = padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    return signature

def verify_sign(signature, file_data, public_key_path):
    with open(public_key_path, 'rb') as key_file:
        public_key = serialization.load_pem_public_key(
            key_file.read(),
            backend = default_backend()
        )
    try:
        public_key.verify(
            signature,
            file_data,
            padding.PSS(
                mgf = padding.MGF1(hashes.SHA256()),
                salt_length = padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return True
    
    except Exception:
        return False
def main():
    aes_key = os.urandom(32)
    print('AES key: ', aes_key)
    with open("C:/Users/user/Desktop/Autoever/실습/test.txt", 'rb') as file:
        file_data = file.read()
    print('Plain text: ', file_data)

    iv, encrypted_text = encrypt_file_aes(file_data, aes_key)
    print('AES Encrypted text: ', encrypted_text)

    decrypted_text = decrypt_file_aes(encrypted_text, aes_key, iv)
    print('AES Decrypted text: ', decrypted_text)

    rsa_encrypted_file =  encrypt_file_rsa(file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Public_key.pem")
    print('RSA Encrypted text: ', rsa_encrypted_file)

    rsa_decrypted_file = decrypt_file_rsa(rsa_encrypted_file, "C:/Users/user/Desktop/Autoever/실습/Key/Private_key.pem")
    print('RSA Decrypted text: ', rsa_decrypted_file)
    file_hash = compute_file_hash("C:/Users/user/Desktop/Autoever/실습/test.txt")
    print("File hash: ", file_hash)

    signature = sign_file(file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Private_key.pem")
    print('Signature of the file: ', signature)

    if verify_sign(signature, file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Public_key.pem"):
        print('Verify success')
    else:
        print('verify failed')

if __name__ == "__main__":
    aes_key = os.urandom(32)
    print('AES key: ', aes_key)
    with open("hello.txt", 'rb') as file:
        file_data = file.read()
    print('Plain test: ', file_data)

    # iv, encrypt_file_data = encrypt_file_aes(file_data, aes_key)
    # print('AES Encrypted text: ', encrypt_file_data)

    # decrypt_file_data = decrypt_file_aes(encrypt_file_data, aes_key, iv)
    # print('AES Decrypted text: ', decrypt_file_data)

    # encrypt_file_data = encrypt_file_rsa(file_data, "key/Public_key1.pem")
    # print("RSA Encrypted text: ", encrypt_file_data)

    # decrypt_file_data = decrypt_file_rsa(encrypt_file_data, "key/Private_key1.pem")
    # print("RSA Decrypted text: ", decrypt_file_data)

    signature = sign_file(file_data, "key/Private_key1.pem", b'private') # 전자서명 생성성
    print('Signature of the file: ', signature)

    if verify_sign(signature, file_data, "key/Public_key1.pem"):
        print('verify success')
    else:
        print('verify failed')

    with open('pwfile.txt', 'rb') as file:
        fake_signature = file.read()
    print('verify fake signature')
    if verify_sign(fake_signature, file_data, "key/Public_key1.pem"):
        print('verify success')
    else:
        print('verify failed')
```

## hash 비교?
```python
import os
import hashlib
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.padding import PKCS7
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization, hashes

def encrypt_file_aes(file_data, aes_key):
    block_size = algorithms.AES.block_size

    padder = PKCS7(block_size).padder()
    padded_data = padder.update(file_data) + padder.finalize()

    iv = os.urandom(16)
    cipher = Cipher(algorithms.AES(aes_key),modes.CBC(iv), backend = default_backend())
    encryptor = cipher.encryptor()
    cipher_text = encryptor.update(padded_data) + encryptor.finalize()
    return iv, cipher_text

def decrypt_file_aes(cipher_text, aes_key, iv):
    block_size = algorithms.AES.block_size

    try:
        cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv), default_backend())
        decryptor = cipher.decryptor()
        padded_data = decryptor.update(cipher_text) + decryptor.finalize()

        unpadder = PKCS7(block_size).unpadder()
        decrypted_text = unpadder.update(padded_data) + unpadder.finalize()
        return decrypted_text
    
    except Exception as e:
        raise ValueError(f'Decryption failed: {e}')

def rsa_key_generation():
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=4096
    )
    public_key = private_key.public_key()

    private_pem = private_key.private_bytes(
        encoding = serialization.Encoding.PEM,
        format = serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm = serialization.BestAvailableEncryption(b'private')
    )

    public_pem = public_key.public_bytes(
        encoding = serialization.Encoding.PEM,
        format = serialization.PublicFormat.SubjectPublicKeyInfo
    )

    key_path = os.path.join(os.getcwd(), 'key')
    os.makedirs(key_path, exist_ok= True)

    private_key_path = os.path.join(key_path, "Private_key1.pem")
    with open(private_key_path, 'wb') as key_file:
        key_file.write(private_pem)

    public_key_path = os.path.join(key_path, "Public_key1.pem")
    with open(public_key_path, 'wb') as key_file:
        key_file.write(public_pem)

def encrypt_file_rsa(file_data, public_key_path):
    with open(public_key_path, 'rb') as key_file:
        public_key = serialization.load_pem_public_key(
            key_file.read(),
            backend = default_backend()
        )
    encrypted_file = public_key.encrypt(
        file_data,
        padding.OAEP(
            mgf = padding.MGF1(algorithm = hashes.SHA256()),
            algorithm = hashes.SHA256(),
            label = None
        )
    )
    return encrypted_file

def decrypt_file_rsa(encrypted_data, private_key_path, password = b'private'):
    with open(private_key_path, 'rb') as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password = password,
            backend = default_backend()
        )
    decrypted_file = private_key.decrypt(
        encrypted_data,
        padding.OAEP(
            mgf = padding.MGF1(algorithm = hashes.SHA256()),
            algorithm = hashes.SHA256(),
            label = None
            )
        )
    return decrypted_file

def compute_file_hash(file_path):
    sha256_hash = hashlib.sha256()
    with open(file_path, 'rb') as file:
        for chunk in iter(lambda: file.read(4096), b""):
            sha256_hash.update(chunk)
    return sha256_hash.hexdigest()

def sign_file(file_data, private_key_path, password = b'private'):
    with open(private_key_path, 'rb') as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password = password,
            backend = default_backend()
        )

    signature = private_key.sign(
        file_data,
        padding.PSS(
            mgf = padding.MGF1(hashes.SHA256()),
            salt_length = padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    return signature

def verify_sign(signature, file_data, public_key_path):
    with open(public_key_path, 'rb') as key_file:
        public_key = serialization.load_pem_public_key(
            key_file.read(),
            backend = default_backend()
        )
    try:
        public_key.verify(
            signature,
            file_data,
            padding.PSS(
                mgf = padding.MGF1(hashes.SHA256()),
                salt_length = padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return True
    
    except Exception:
        return False
def main():
    aes_key = os.urandom(32)
    print('AES key: ', aes_key)
    with open("C:/Users/user/Desktop/Autoever/실습/test.txt", 'rb') as file:
        file_data = file.read()
    print('Plain text: ', file_data)

    iv, encrypted_text = encrypt_file_aes(file_data, aes_key)
    print('AES Encrypted text: ', encrypted_text)

    decrypted_text = decrypt_file_aes(encrypted_text, aes_key, iv)
    print('AES Decrypted text: ', decrypted_text)

    rsa_encrypted_file =  encrypt_file_rsa(file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Public_key.pem")
    print('RSA Encrypted text: ', rsa_encrypted_file)

    rsa_decrypted_file = decrypt_file_rsa(rsa_encrypted_file, "C:/Users/user/Desktop/Autoever/실습/Key/Private_key.pem")
    print('RSA Decrypted text: ', rsa_decrypted_file)
    file_hash = compute_file_hash("C:/Users/user/Desktop/Autoever/실습/test.txt")
    print("File hash: ", file_hash)

    signature = sign_file(file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Private_key.pem")
    print('Signature of the file: ', signature)

    if verify_sign(signature, file_data, "C:/Users/user/Desktop/Autoever/실습/Key/Public_key.pem"):
        print('Verify success')
    else:
        print('verify failed')

if __name__ == "__main__":
    aes_key = os.urandom(32)
    print('AES key: ', aes_key)
    with open("hello.txt", 'rb') as file:
        file_data = file.read()
    print('Plain test: ', file_data)

    # iv, encrypt_file_data = encrypt_file_aes(file_data, aes_key)
    # print('AES Encrypted text: ', encrypt_file_data)

    # decrypt_file_data = decrypt_file_aes(encrypt_file_data, aes_key, iv)
    # print('AES Decrypted text: ', decrypt_file_data)

    # encrypt_file_data = encrypt_file_rsa(file_data, "key/Public_key1.pem")
    # print("RSA Encrypted text: ", encrypt_file_data)

    # decrypt_file_data = decrypt_file_rsa(encrypt_file_data, "key/Private_key1.pem")
    # print("RSA Decrypted text: ", decrypt_file_data)

    # signature = sign_file(file_data, "key/Private_key1.pem", b'private') # 전자서명 생성성
    # print('Signature of the file: ', signature)

    # if verify_sign(signature, file_data, "key/Public_key1.pem"):
    #     print('verify success')
    # else:
    #     print('verify failed')

    # with open('pwfile.txt', 'rb') as file:
    #     fake_signature = file.read()
    # print('verify fake signature')
    # if verify_sign(fake_signature, file_data, "key/Public_key1.pem"):
    #     print('verify success')
    # else:
    #     print('verify failed')

    hash_data = compute_file_hash(file_data)
    print('Hash of the file:', hash_data)
    hash_file = compute_file_hash("hello.txt")
    print('Hash file: ', hash_file)

    if hash_data == hash_file:
        print('Hash match')
    else:
        print('Hash no match')
```
