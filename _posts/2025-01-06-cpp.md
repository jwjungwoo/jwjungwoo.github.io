---
layout: single
title:  "C++ 프로그래밍"
categories: autoever
tag:
author_profile: false #true면 글 안에서 내 프로필 보여줌
sidebar:
    nav: "autoever"
#search: false
---

# C++ 기본개념

## C++ 특징

✅ c: 절차 지향적, 함수 지향적 (함수가 가장 중요함) -> c에서 가장 중요하다 생각하는 것: 함수포인터; 이유: "c가 객체 지향 프로그래밍처럼 다형성을 구현하기 어렵지만 함수 포인터가 이를 가능하게 해서 가장 중요하다 생각합니다."     
✅ c++: 객체 지향 프로그래밍(OOP: Object Orientied Programming)   
OOP 언어의 중요한 특징 4가지   
1. Encapsulation (캡슐화)   
2. Polymorphism (다형성)   
3. Inheritance (상속)   
4. Abstraction (추상화)   

## class

struct의 멤버변수는 항상 public이고 c++은 public과 private을 지정할 수 있다. 그리고 c++은 내부에 멤버 함수를 구현할 수 있다.   
또한 class의 선언은 메모리 사용 X, 정의: 메모리 사용 O
```c++
#include <iostream>
using namespace std;

class point_c {
public: // 접근지정자 
    int x; // 멤버변수
    int y;

    void set_x(int a) { // 멤버함수
        x = a;
    }
    void set_y(int b) {
        y = b;
    }
};

struct point_t {
    int x;
    int y;
    void set_x(int a) {
        x = a;
    }
    void set_y(int b) {
        y = b;
    }
};

int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);

    point_c c = { 11,22 }; // 가급적 만들면서 초기화하라

    cout << c.x << " " << c.y;
    return 0;
}
```   
   
✅ 어느 코드가 더 좋아 보일까?   
```c++
void drawRect(int x1, int y1, int x2, int y2);
```   
```c++
void drawRect(rectangle_t r);
```   
당연히 후자다.   

✅ 인자는 가급적 const를 붙이는게 좋다.   
```c
// c++
#include <stdio.h>

typedef struct _rectangle_t {
	int x1;
	int y1;
	int x2;
	int y2;
} rectangle_t;

int get_area_rect(const rectangle_t* r) { // ★★★
	return ((r->x2 - r->x1) * (r->y2 - r->y1));
}

void draw_rect(const rectangle_t* r) { // ★★★
	printf("cc 사각형을 그렸어요.\r\n");
}


int main(void) {
	rectangle_t r = {10, 10, 20, 20};
	int area = get_area_rect(&r); // ★★★
	printf("사각형의 넓이는 %d입니다.\r\n", area);
	draw_rect(&r); // ★★★
	return 0;
}
```   

c도 구조체 내에 함수 포인터써서 멤버함수를 만들 수 있다. 다만, 그렇게 잘 쓰이진 않는다.   
```c
//c
#include <stdio.h>

int mul(int x, int y) {
	return x * y;
}

typedef struct _rectangle_t {

	int x1;
	int y1;
	int x2;
	int y2;

	int(*t_mul)(int a, int b);

} rectangle_t;

int main(void) {
	rectangle_t r = { 10, 10, 20, 20 };
	int(*pp) = &mul;
	
	r.t_mul = pp;

	printf("두 수의 곱은 %d입니다.\r\n", r.t_mul(2, 3));
	return 0;
}
```

## 클래스내의 static 변수(=클래스 변수) 및 함수

✅ 클래스 변수란?   
```c++
#include <iostream>

class Foo {
public:
	int a;
	static int x; // (1) 정적 멤버 변수 = 클래스 변수 = static 

	void func1() {};

	static void sfunc1() { // (2) 정적 멤버 함수
		std::cout << "sfunc1()" << std::endl;
	}
};

int Foo::x = 12; // (3) 정적 변수(=클래스변수)의 초기화 방법

int main() {
	//a = 11; // (4) 에러! 인스턴스가 없기 때문에 에러!

	std::cout << "Foo::x=" << Foo::x << std::endl;
	// (2) ok 정적 변수는 객체가 없어도 (=인스턴스가 없어도) 가능하다

	Foo::sfunc1();

	Foo::x = 33;
	std::cout << "Foo::x=" << Foo::x << std::endl;

	Foo foo;
	foo.a = 11;

	return (0);
}
```
   
✅ 멤버 변수와 클래스 변수의 차이점   
출력 뭐 나올지 생각해보기   
```c++
#include <iostream>
using namespace std;

class Fishbun {
public:
	int cnt1; // cnt1은 붕어빵 각각에 존재하나
	static int cnt2; // cnt2는 붕어빵 틀에 존재한다.

	Fishbun() : cnt1{ 0 }
	{
		++cnt1;
		++cnt2;
	}
};

int Fishbun::cnt2 = 0;

int main() {
	Fishbun f1;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	Fishbun f2;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	Fishbun f3;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	return (0);
}
```

## class 객체 생성

✅ 예시
```c++
#include <iostream>
#include <cstdlib>
class Sample {
public:
	int a;
	int b;
};

int main(void) {
	Sample s1; // ok. 스택에 할당
	Sample s2(); // (1) warning!! 경고 발생! 객첸지 생성잔지 헷갈림

	Sample* s3 = new Sample; // ok
	s3->a = 11;
	std::cout << "s3(a, b)=(" << s3->a << "," << s3->b << ")" << std::endl;

	Sample* s4 = new Sample(); // ok
	s4->a = 33;
	std::cout << "s4(a, b)=(" << s4->a << "," << s4->b << ")" << std::endl; // (2)

	return (0);
}
```

## this 포인터

✅ this는 자기 자신의 참조를 돌려준다.   
```c
#include <iostream>

class Point {
private:
	int x{ 0 };
	int y{ 0 };

public:
	void set(int a, int b) {
		x = a;
		y = b;
		std::cout << this << std::endl;
	}
};

int main() {
	Point pt1;
	Point pt2;

	std::cout << &pt1 << std::endl;
	std::cout << &pt2 << std::endl;

	pt1.set(11, 22);
	pt2.set(33, 44);
	return 0;
}
```   
   
✅ this return   
```c++
#include <iostream>

class Counter {
public:
	int count;
public:
	void reset(int count = 0) {
		this->count = count;
	}
	Counter* increment() {
		++count;
		return this;
	}
	Counter& decrement() {
		--count;
		return *this;
	}
};

int main() {
	Counter c;
	c.reset();
	c.increment()->increment()->increment()->increment();

	std::cout << c.count << std::endl;
	c.decrement().decrement().decrement();
	std::cout << c.count << std::endl;

	return 0;
}
```   
   
✅ 근데 이거 뭐에다 써? cout이 이런 형태로 되어있다.   
```c++
std::cout<<”a”<<”b”<<”c”;
std::cout.operator<<(”A”)
return *this
// 즉 std::cout을 다시 반환
```
