---
layout: single
title:  "C++ 프로그래밍"
categories: autoever
tag:
author_profile: false #true면 글 안에서 내 프로필 보여줌
sidebar:
    nav: "autoever"
#search: false
---

# C++ 기본개념

## OOP

✅ c: 절차 지향적, 함수 지향적 (함수가 가장 중요함) -> c에서 가장 중요하다 생각하는 것: 함수포인터; 이유: "c가 객체 지향 프로그래밍처럼 다형성을 구현하기 어렵지만 함수 포인터가 이를 가능하게 해서 가장 중요하다 생각합니다."     
✅ c++: 객체 지향 프로그래밍(OOP: Object Orientied Programming)   
OOP 언어의 중요한 특징 4가지   
1. Encapsulation (캡슐화)   
2. Polymorphism (다형성)   
3. Inheritance (상속)   
4. Abstraction (추상화)   

## class

struct의 멤버변수는 항상 public이고 c++은 public과 private을 지정할 수 있다. 그리고 c++은 내부에 멤버 함수를 구현할 수 있다.   
또한 class의 선언은 메모리 사용 X, 정의: 메모리 사용 O
```c++
#include <iostream>
using namespace std;

class point_c {
public: // 접근지정자 
    int x; // 멤버변수
    int y;

    void set_x(int a) { // 멤버함수
        x = a;
    }
    void set_y(int b) {
        y = b;
    }
};

struct point_t {
    int x;
    int y;
    void set_x(int a) {
        x = a;
    }
    void set_y(int b) {
        y = b;
    }
};

int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);

    point_c c = { 11,22 }; // 가급적 만들면서 초기화하라

    cout << c.x << " " << c.y;
    return 0;
}
```   
   
✅ 어느 코드가 더 좋아 보일까?   
```c++
void drawRect(int x1, int y1, int x2, int y2);
```   
```c++
void drawRect(rectangle_t r);
```   
당연히 후자다.   

✅ 인자는 가급적 const를 붙이는게 좋다.   
```c
// c++
#include <stdio.h>

typedef struct _rectangle_t {
	int x1;
	int y1;
	int x2;
	int y2;
} rectangle_t;

int get_area_rect(const rectangle_t* r) { // ★★★
	return ((r->x2 - r->x1) * (r->y2 - r->y1));
}

void draw_rect(const rectangle_t* r) { // ★★★
	printf("cc 사각형을 그렸어요.\r\n");
}


int main(void) {
	rectangle_t r = {10, 10, 20, 20};
	int area = get_area_rect(&r); // ★★★
	printf("사각형의 넓이는 %d입니다.\r\n", area);
	draw_rect(&r); // ★★★
	return 0;
}
```   

c도 구조체 내에 함수 포인터써서 멤버함수를 만들 수 있다. 다만, 그렇게 잘 쓰이진 않는다.   
```c
//c
#include <stdio.h>

int mul(int x, int y) {
	return x * y;
}

typedef struct _rectangle_t {

	int x1;
	int y1;
	int x2;
	int y2;

	int(*t_mul)(int a, int b);

} rectangle_t;

int main(void) {
	rectangle_t r = { 10, 10, 20, 20 };
	int(*pp) = &mul;
	
	r.t_mul = pp;

	printf("두 수의 곱은 %d입니다.\r\n", r.t_mul(2, 3));
	return 0;
}
```

## 클래스내의 static 변수(=클래스 변수) 및 함수

✅ 클래스 변수란?   
```c++
#include <iostream>

class Foo {
public:
	int a;
	static int x; // (1) 정적 멤버 변수 = 클래스 변수 = static 

	void func1() {};

	static void sfunc1() { // (2) 정적 멤버 함수
		std::cout << "sfunc1()" << std::endl;
	}
};

int Foo::x = 12; // (3) 정적 변수(=클래스변수)의 초기화 방법

int main() {
	//a = 11; // (4) 에러! 인스턴스가 없기 때문에 에러!

	std::cout << "Foo::x=" << Foo::x << std::endl;
	// (2) ok 정적 변수는 객체가 없어도 (=인스턴스가 없어도) 가능하다

	Foo::sfunc1();

	Foo::x = 33;
	std::cout << "Foo::x=" << Foo::x << std::endl;

	Foo foo;
	foo.a = 11;

	return (0);
}
```
   
✅ 멤버 변수와 클래스 변수의 차이점   
출력 뭐 나올지 생각해보기   
```c++
#include <iostream>
using namespace std;

class Fishbun {
public:
	int cnt1; // cnt1은 붕어빵 각각에 존재하나
	static int cnt2; // cnt2는 붕어빵 틀에 존재한다.

	Fishbun() : cnt1{ 0 }
	{
		++cnt1;
		++cnt2;
	}
};

int Fishbun::cnt2 = 0;

int main() {
	Fishbun f1;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	Fishbun f2;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	Fishbun f3;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	return (0);
}
```

## class 객체 생성

✅ 예시
```c++
#include <iostream>
#include <cstdlib>
class Sample {
public:
	int a;
	int b;
};

int main(void) {
	Sample s1; // ok. 스택에 할당
	Sample s2(); // (1) warning!! 경고 발생! 객첸지 생성잔지 헷갈림

	Sample* s3 = new Sample; // ok
	s3->a = 11;
	std::cout << "s3(a, b)=(" << s3->a << "," << s3->b << ")" << std::endl;

	Sample* s4 = new Sample(); // ok
	s4->a = 33;
	std::cout << "s4(a, b)=(" << s4->a << "," << s4->b << ")" << std::endl; // (2)

	return (0);
}
```

## this 포인터

✅ this는 자기 자신의 참조를 돌려준다.   
```c
#include <iostream>

class Point {
private:
	int x{ 0 };
	int y{ 0 };

public:
	void set(int a, int b) {
		x = a;
		y = b;
		std::cout << this << std::endl;
	}
};

int main() {
	Point pt1;
	Point pt2;

	std::cout << &pt1 << std::endl;
	std::cout << &pt2 << std::endl;

	pt1.set(11, 22);
	pt2.set(33, 44);
	return 0;
}
```   
   
✅ this return   
```c++
#include <iostream>

class Counter {
public:
	int count;
public:
	void reset(int count = 0) {
		this->count = count;
	}
	Counter* increment() {
		++count;
		return this;
	}
	Counter& decrement() {
		--count;
		return *this;
	}
};

int main() {
	Counter c;
	c.reset();
	c.increment()->increment()->increment()->increment();

	std::cout << c.count << std::endl;
	c.decrement().decrement().decrement();
	std::cout << c.count << std::endl;

	return 0;
}
```   
   
✅ 근데 이거 뭐에다 써? cout이 이런 형태로 되어있다.   
```c++
std::cout<<”a”<<”b”<<”c”;
std::cout.operator<<(”A”)
return *this
// 즉 std::cout을 다시 반환
```

## namespace
✅ 범위는 줄여쓰면 좋다.   
```c
#include <iostream>
using std::cout;
using std::cin;

namespace audio {
	void init() {
		cout << "hello\n";
	}
}
namespace video {
	void init() {
		cout << "hello\n";
	}
}

using namespace audio;

int main() {
	init();
	video::init();
	return 0;
}
```

## 예외 처리
✅ 예외 처리   
오류를 처리하기 위한 구문 try, catch, throw를 지원한다.   

## 소수점 자리수 조정
✅ 개념     
cout으로 출력시 기본적으로 6자리에 맞춰서 출력해주는데   
간혹 자릿수를 짧게 혹은 길게 바꿔줘야 할 필요가 있다.   
이에 대해 알아보자.   
```c++
#include <iostream>
using namespace std;

int main() {
	double a = 12345.12345;
	cout << a << endl; // 그냥 출력하면 얼마가 나올까? 12345.12345? no
	// 12345.1가 나온다. 왜요? 6자리고 고정되어 있다.

	//실수에서 자릿수를 조절하고 싶을때
	cout.precision(7); // 12345.12 출력된다. (n)개를 출력한다.
	cout << a << endl;

	double b = 3.1415;
	cout << b << endl; // 당연히 3.1415 전부다 출력되는데,
	cout.precision(3); // 나는 그냥 3.14까지만 출력하고 싶다면, 정밀도 재조정
	cout << b << endl; // 3.14 출력

	double c = 2.7182818;
	cout.fixed; // 기존 설정을 그대로 사용하고 싶다면 fixed
	// preciosn(3)를 써줘도 되지만 불편하니까.
	cout << c << endl;  // 2.72 출력

	// fixed를 해제하려면?
	// 정밀도를 재조정해도 되고
	cout.unsetf(ios::fixed);
	cout << c << endl; // 해제되어 2.72 출력(마지막 0.008은 반올임 되었다.)

	double d = 12345.12345;
	cout << d << endl; // 12345.1이 출력되는건 맞는데, 지수형태로 출력한다. 1.23e+04 출력

	cout.precision(8); // 다시 설정해 준다.
	//std::cout.unsetf(std::ios::scientific); //지수 출력
	cout << d << endl; // 12345.123 출력

	return (0);
}
```

## 함수 오버로딩

✅ 오버라이딩과 오버로딩의 차이   
오버라이딩은 상속받은 함수와 이름이 같아도 재정의하는 것이다. 오버로딩은 함수 이름이 같고 인자가 다른 것이다. 다만 오버로딩에서 반환타입으로는 구분할 수 없다.   

## 네임 맹글링

✅ 네임 맹글링 (name mangling)   
컴파일러는 인자만 보고 두 함수가 다른 것을 안다.   
```c++
squre(3);
square(3.1);
```
컴파일러가 이름을 슬쩍 바꿔준다.   
실제로 square_int 이렇게 바꿔주는건 아니고, 컴파일러가 알아서 바꿔준다.   
```c++
int square_○○○(int a) {}
double square_●●●(double a) {}
// square@@YAHH@Z ← square_○○○
// square@@YANN@Z ← square_●●●
```

## inline 함수
inline함수는 매크로처럼 코드레벨에서 치환된다. 따라서 함수 호출과정(스택에 넣고 빼고)가 없어서 훨씬 빠르다. 
즉, 성능, 효율성이 좋다. 코드가 간단하다면 인라인 함수를 쓰자. 다만 그냥 비슷비슷하다 하셨다.

## 함수 템플릿

```c++
#include <iostream>

template<typename Hey>
Hey square(Hey a) {
	return (a * a);
}
// Hey에 타입을 보내주면 Hey를 채워준다.
// 위의 코드는 함수가 아니야. 템플릿이야

int main() {
	int a = square(3); // 이것도 동작하지만 ★★이건 함수가 아니야, 함수 템플릿이야
	double b = square(3.2);

	std::cout << a << std::endl;
	std::cout << b << std::endl;

	int c = square<int>(2); // 이렇게 적자!! 함수를 만들어 준다! 템플릿 인스턴스화
	double d = square<double>(3.2);
	std::cout << c << std::endl;
	std::cout << d << std::endl;

	return 0;
}
```

## for_each

```c++
#include <iostream>
#include <algorithm>
using namespace std;

void print_one(int one) {
	cout << one << "\n";
}

int a[5] = { 3,2,1,3,2 };
int main() {

	for_each(a, a + 5, print_one);
	return 0;
}
```   

## reference

✅ C에는 없고 C++에만 있는 reference   
가급적이면 reference를 쓰자.   
   
✅ pointer vs reference   
pointer(참조)는 null값이 들어갈 수 있으나 이는 문제를 일으킬 수 있음. 또한 가리키는 대상이 바뀔 수 있음. 반면 reference는 초기화부터 값을 지정해줘야 생성됨. 
또한 가리키는 대상 못 바꿈. 따라서 안정적임. 물론 pointer도 const를 붙임으로써 reference를 따라할 수 있으나 그냥 reference 쓰는게 좋다.   
   
✅ 모듈간 의존도   
하나를 고쳐도 나머지는 영향을 최대한 안 받게 해야하므로 전역변수 사용은 최대한 지양해야한다. 따라서 reference 사용하는게 중요   
   
✅ C++에서 call by reference를 pass by reference라고 한다.   
하나의 주소에 이름이 두 개 생겼다 보면됨.   
```c++
#include <iostream>
using namespace std;

int main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);

	int k = 11;
	int* pa = &k;
	*pa = 22;
	cout << k << "\n";

	int& ra = k; // C++에는 reference 라는게 존재한다. 
	ra = 33;
	cout << ra << k << *pa << "\n";

	cout << &pa << "\n" << &ra << "\n" << &k << "\n"; // 포인터는 주소가 다르나 ra와 k의 주소는 값다. C++의 reference는 한 주소를 원래 변수와 reference가 나눠쓴다.

	return 0;
}
```   
✅ reference를 함수인자로 받을 땐 뭐를 써야할까?   
```c++
#include <iostream>

void bts(int  x) { x += 1; } // (1) Call by value
void exo(int* p) { *p += 1; } // (2) Call by reference 참조 버전
void ses(int& r) { r += 1; } // (3) Call by reference 참조 버전...? 위에도 참조 아래도 참조?

int main() {
	int a = 11;
	int b = 22;
	int c = 33;

	bts(a); // (1)
	exo(&b); // (2)
	//ses(★); // (3) ★는 무엇으로 적어야 할까?
	ses(c);

	std::cout << "a=" << a << std::endl;
	std::cout << "b=" << b << std::endl;
	std::cout << "c=" << c << std::endl;

	return (0);
}
```   
✅ swap함수 만들기   
```c++
#include <iostream>
using namespace std;

void swap(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
	return;
}
int main() {
	int a = 11, b = 22;
	swap(a, b);
	cout << a << " " << b << "\n";
	swap(a, b);
	cout << a << " " << b;
	return (0);
}
```
✅ const 써주기 중요!!!!!!!   
```c++
#include <iostream>

typedef struct _point_t {
	int x;
	int y;
} point_t;

void print_point(const point_t& point) { // 수정되지 않는다면 const
	std::cout << "point(x,y)=(" << point.x << "," << point.y << ")" << std::endl;
}

int main() {
	point_t pt1 = { 11,22 };
	print_point(pt1); // pt1의 복사본이 전달된다. call by value

	point_t pt2 = { 33,44 };
	print_point(pt2);

	return (0);
}
```   
✅ 값에 의한 반환, 참조에 의한 반환 (return by value vs return by reference)   
```c++
class Point {
public:
	int x;
	int y;
};

Point pt = { 11,22 };

Point f1() { // return by value
	return pt; // pt가 리턴되는게 아니라
	// 리턴용 임시객체(temporary boject)가 만들어서 돌려줌
	// 정확히는 복사 생성자가 호출됨
}

Point& f2() { // return by reference
	return pt; // 진짜 pt를 돌려줌
}

int main() {
	//f1().x = 11; // 리턴용임시객체.x = 11; // lvalue가 될수 없어 컴파일 에러
	f2().x = 22; // pt.x= 22 // 이건 된다.
}
```   
✅ template으로 만들기   
기존의 swap함수를 좀더 범용적으로 만들어 보자.   
int 타입만 swap 할수 있는데, int, char, double도 swap할수 있게 바꿔보자.   
   
내가 만든 유용한 유틸리니까 namesapce를 적용해보았다.   
int말고 다른 타입도 변환하고 싶을때 template을 사용하면 매우매우 편리하다.   
inline을 사용하면 좀더 성능향상을 가져올수 있다.   
```c++
#include <iostream>

namespace my_util {
	template <class T> 
	inline void swap(T& a, T& b) {
		T temp = a;
		a = b;
		b = temp;
	}
}

int main() {
	int a = 11;
	int b = 22;
	my_util::swap<int>(a, b);		// pass by reference
	std::cout << "(a,b)=(" << a << "," << b << ")" << std::endl;

	double c = 12.34;
	double d = 23.45;
	my_util::swap<double>(c, d);
	std::cout << "(c,d)=(" << c << "," << d << ")" << std::endl;
	return (0);
}
```

# 데이터 타입과 변수 (type and variable)

## 유니폼 초기화 (Uniform initialization)
요건 쓸만하다.   
```c++
struct point {
	int x;
	int y;
};

class rect {
public:
	int x1;
	int y1; // x2,y2를 넣어 2점을 만들어야 하지만, 
	// 클래스 초기화만 볼것이므로 x2, y2는 뺐다.
	rect(int a, int b) {
		x1 = a;
		y1 = b;
	}
};

int main(void) {
	// 초기화 방법이 다양해서 헷갈린다.
	int          a1 = 0;			//기본 데이터형은 =연산자로 초기화, 괄호가 없다.
	struct point b1 = { 0,0 };		// 구조체는 중괄호
	int          c1[3] = { 11,22,33 };	// 배열은 중괄호
	rect         r1(1, 2);				// 클래스는 소괄호

	int          a2 = {0};
	struct point b2 = { 0,0 };
	int          c2[3] = { 11,22,33 };
	rect         r2 = {1,2};

	int          a3{ 0 };
	int			 a4(11); // not good 생성자 스타일로 초기화 헷갈리니까 위에껄 쓰자
	struct point b3 { 0, 0 };
	//struct point b4(1, 2); // error
	int          c3[3]{ 11,22,33 };
	rect         r3{ 1,2 };
	rect         r4( 1,2 );// 구조체는 안되지만 클래스는 가능
	return 0;
}
```

## bool
c에서 bool은 실제론 int형이다.   

# class
## 정보 은닉과 접근지정자 (Data Hiding and Access Modifier)
✅ 멤버 변수에 외부접근을 허용하면(=노출하면) 잘못된 값이 저장될 우려가 있다.   
따라서 접근지정자를 (외부에서 접근 못하게) 범위가 가장 좁은 private으로 바꿔준다.   
```c
#include <iostream>
#include <string>

class Person {
public:
	std::string name= ""; // 항상 초기화 시키는 습관을 들이자.

private:
	int age= 0;

public:
	void setAge(int a) {
		age = a;
	}
	int getAge() const{
		return age;
	}
};

int main() {
	Person p;
	p.name = "정예림";
	p.setAge(19);
	std::cout << p.name << "의 나이는 " << p.getAge() << "입니다." << std::endl;
	return 0;
}
```

## 데이터 무결성: setter 함수를 잘 만들자.

✅ 데이터 무결성이란?   
데이터 무결성이란   
- 몸무게가 음수라거나   
- 나이가 음수라거나   
와 같이 데이터가 이상한 상태를 갖는 것을 말한다.   
   
클래스를 만들때   
- 멤버 변수에 직접 접근하게 하는 것보다   
- setter getter함수를 사용하면   
데이터 무결성이 보장이 더 잘된다.

```c++
#include <iostream>
#include <string>

class Person {
public:
	std::string name= ""; // 항상 초기화 시키는 습관을 들이자.

private:
	int age= 0;

public:
	void setAge(int val) {
		if (val >= 1 && val < 150) { // (1)
			age = val;
		}
		else {
			printf("나이 입력값이 %d로 잘못되었습니다.\r\n", val);
		}
	}
	int getAge() const{
		return age;
	}
};

int main() {
	Person p;
	p.name = "정예림";
	p.setAge(190);
	std::cout << p.name << "의 나이는 " << p.getAge() << "입니다." << std::endl;
	return 0;
}
```

## 생성자 소멸자
```c++
// 기본문법
#include <iostream>

class Person {
private:
	std::string name;
	int age;
public:
	Person() {
		name = "abc";
		age = 83;
		std::cout << "created\n";
	}
	Person(std::string a, int b) {
		name = a;
		age = b;
	}
	~Person() {
		std::cout << "deleted\n";
	}
};

int main() {
	Person p1;
	Person p2("apple", 33);
	std::cout << "main running\n";
}
```
