---
layout: single
title:  "OS 공부"
categories: autoever
tag: 
author_profile: false #true면 글 안에서 내 프로필 보여줌
sidebar:
    nav: "counts"
#search: false
---

# OS 란?

OS: 모든 하드웨어 자원을 관리해주는 프로그램   
하드웨어 자원에는 CPU, 메모리 I/O 디바이스 등이 있다. 묶어서 컴퓨터 자원(resource)이라고 한다. 

예를 들어 키보드를 입력하는 등의 작업을 할 때 사용자는 동작원리를 몰라도 OS 가 중간자 역할을 한다.   
   
3가지의 작업 처리 방식을 꼽자면 batch, transaction processing, timesharing 이다.   
1. 배치 처리: 여러 작업들을 한꺼번에 모아서 자동으로 순차적으로 처리하는 방식
2. 트랜잭션 처리: 작은 단위의 처리 작업을 즉시 처리하는 방식
3. 시분할 처리: 하나의 컴퓨터를 여러 사용자가 동시에 사용하는 것처럼 만들어주는 처리 방식
   
os 는 언제 작동하나?   
1. system call 요청될 때   
2. interrupt 발생   
3. fault 뜰 때 (예외처리)   

# OS 구조

## kernel

os 의 핵심 부분으로, hw 와 sw 사이를 중계해주는 프로그램이다. 프로세스, 메모리, 저장공간 등을 관리한다.

## interface

사용자의 명령을 컴퓨터에 전달하고 결과를 사용자에게 알려주는 소통의 역할을 한다. GUI(Graphical User Interface)와 CLI(Command Line Interface)로 나눌 수 있다. 아이콘과 마우스를 사용하냐, 명령어를 사용하냐의 차이.

## system call

사용자나 프로그램이 직접 컴퓨터 자원에 접근하는 것을 막고 커널을 보호하기 위해 만든 코드 집합이다. 시스템 콜을 통해 커널에 접근할 수 있다.
   
시스템콜의 유형 5가지   
1. Process Control: 어떤 걸 시작하고, 어떤 걸 멈추게 할지를 정함   
2. File Management: 다운로드, 저장, 삭제 등   
3. Device Management: 컴퓨터에 달려있는 디바이스들을 os 에서 시스템콜 형태로 관리함   
4. Information Maintenance: 컴퓨터가 현재 사용하는 정보들   
5. Communications (between computer and computer): 주로 네트워크를 생각하면 됨   

## driver

hw 장치와 os 간의 통신을 가능하게 하는 sw.

# user mode vs kernel mode

## 구조

![user_kernel_mode](https://github.com/user-attachments/assets/45c14f7a-c8b6-44aa-b3b5-18022a5dada4)   
   
open(): os 에 파일을 여는 요청을 보냄. os 는 파일을 열고 파일 descriptor(프로그램이 해당 파일에 접근하기 위해 필요한 정수값) 를 반환해줌.   
write(): os 에 지정된 파일 descriptor 에 데이터를 쓰는 요청을 보냄. os 가 이 작업을 실제로 처리함.   

## 설명

User mode: CPU 명령어 사용을 제한   
Kernel mode: CPU 명령어를 사용해 hw 를 직접 제어   
   
User mode 와 Kernel mode 사이는 system call 을 통해서 전환된다.   
   
## 키보드 작동 과정

키보드 인터럽트라는 system call 호출한다.   
키보드를 누르는 순간 유저모드에서 키보드를 담당하는 프로그램이 os 한테 키보드 인터럽트를 날려서 그때까지 하던일을 멈추고, 키보드에 대한 처리를 하게된다.   

# os 종류

1. Unix(유닉스): C 언어로 만들어짐   
2. linux: 유닉스 계열의 운영체제   
   
다양한 이유: 디바이스가 다 다르기 때문이다. 그래서 CPU 아키텍처도 다르고, 시스템콜도 달라서 os 를 따로 만들어써야한다.

# Monolithic kernel vs MicroKernel

Monolithic kernel: os 의 핵심 기능들을 하나의 큰 커널 안에 모두 포함하는 방식. 속도 빠른, 안정성 낮음. 모든 절차가 유기적으로 연결돼있다.   
Microkernel: os 의 핵심 기능만 커널에 남기고, 나머지는 유저 공간에서 실행하는 방식.


# 디스패치

## os 관점의 디스패치

✅ 디스패치란?   
작업을 실제로 CPU 에 할당해 실행시키는 과정. 문맥에 따라 뜻이 조금 다르다.   
   
os 관점의 디스패치   
프로세스를 CPU 에 연결해 실행시키는 것   
: ready 상태인 프로세스를 실제로 CPU 에 할당하여 running 상태로 전환시키는 것   
   
반면 스케줄링은 누가 실행될지 결정하는 것이다.

## 프로그래밍 관점의 디스패치

✅ 정적 디스패치: 컴파일타임에 어떤 함수가 호출될지 결정   
오버로딩 같은 상황   
   
✅ 동적 디스패치: 런타임에 실제 객체의 타입을 보고 어떤 함수가 실행될지 결정   
ex: 가상함수 호출 -> vtable을 사용   

## 하드웨어 관점의 디스패치

✅ 인터럽트 처리 후 ISR 을 실행시키는 것도 일종의 디스패치

# 가상함수

## 일반함수 vs 가상함수

✅ 정적 타입만 보냐, 실제 객체 타입을 보냐   
둘의 차이는 정적 바인딩과 동적 바인딩의 차이이다.   
일반 함수는 컴파일 시점에 결정되지만 가상 함수는 실행 시점에 실제 객체를 보고 결정한다.   
   
✅ 예시   
```c
class Derived 가 class Base 를 상속할 때 둘 다 print() 함수가 있을 때
일반함수로 하면 Base의 print()함수가, 가상함수로 하면 Derived의 print()함수가 실행된다.

Base* ptr = new Derived();
ptr->print();  // 클래스들에서 일반함수 사용한 후 출력: Base

Base* ptr = new Derived();
ptr->print();  // 클래스들에서 가상함수 사용한 후 출력: Derived

이유: Base* 포인터는 정적 타입만 보기 때문에 Base::print() 호출됨.
이유: virtual 덕분에 런타임에 실제 객체 타입(Derived)에 따라 Derived::print() 호출됨.
```

## vtable

✅ Virtual Table   
클래스마다 존재하는 가상 함수들의 주소를 담은 테이블이다. 즉, 런타임에 어떤 가상 함수가 호출될지를 결정할 때 참조되는 함수 포인터 목록이다.   
   
# 오버로딩 vs 오버라이딩

✅ 오버로딩 성립 조건   
1. 함수의 이름이 같아야 한다.   
2. 매개변수의 수가 달라야 한다.   
3. 매개변수의 수가 같으면 자료형이 달라야한다.   
4. 리턴형은 같아도 달라도 상관없다.   
   
✅ 오버라이딩   
상위 클래스에서 정의된 변수와 메소드의 내용을 하위 클래스에서 변경하여 재정의하는 것   
parent a; 에서 a는 parent꺼, child b;에서 b는 child꺼로 작동함.   
   
# 주기억장치 vs 보조기억장치



