---
layout: single
title:  "AUTOSAR"
categories: autoever
tag: 
author_profile: false #true면 글 안에서 내 프로필 보여줌
sidebar:
    nav: "counts"
#search: false
---

# 소프트웨어 플랫폼
## 차량 vs 컴퓨터
<img src="https://github.com/user-attachments/assets/a59cb526-54ae-49b8-966d-41875f3e3c8d" width="600" height="340">   
통합제어기를 가장 잘 만드는 기업은 테슬라이다.

## 통합제어기
✅ 여러 개 일을 동시에 처리해야함 -> 제어기 sw 복잡해짐.   
<img src="https://github.com/user-attachments/assets/5a33823e-7c29-43b5-95de-75c0e5e5cc22" width="600" height="400">   
ISO 26262를 따르면 법적인 책임은 안 진다. 근데 AUTOSAR가 ISO26262를 따름.   

✅ 국제 표준 플랫폼(AUTOSAR)   
AUTOmotive Open System ARchitecture의 약자로써 비용 절감, 안정성 확보를 위해 만들어졌다.   
ㅈ--
layout: single
title:  "AUTOSAR"
categories: autoever
tag: 
author_profile: false #true면 글 안에서 내 프로필 보여줌
sidebar:
    nav: "counts"
#search: false
---

# 소프트웨어 플랫폼
## 차량 vs 컴퓨터
<img src="https://github.com/user-attachments/assets/a59cb526-54ae-49b8-966d-41875f3e3c8d" width="600" height="340">   
통합제어기를 가장 잘 만드는 기업은 테슬라이다.

## 통합제어기
✅ 여러 개 일을 동시에 처리해야함 -> 제어기 sw 복잡해짐.   
<img src="https://github.com/user-attachments/assets/5a33823e-7c29-43b5-95de-75c0e5e5cc22" width="600" height="400">   
ISO 26262를 따르면 법적인 책임은 안 진다. 근데 AUTOSAR가 ISO26262를 따름.   

## AUTOSAR
✅ 국제 표준 플랫폼(AUTOSAR)   
AUTOmotive Open System ARchitecture의 약자로써 비용 절감, 안정성 확보를 위해 만들어졌다.   
CP(Classic Platform): 자체os를 가지고있음.   
AP(Adaptive Platform): 리눅스 or RTOS. 자율주행때문에 2020년에 탄생함. 외부 플랫폼을 많이 사용함.   
   
LG가 차량디스플레이를 잘 만드는데 vector회사 라이센스를 쓰면서 1년에 수십억을 낸다. 따라서 현대차가 mobilgene을 만든 것은 그당시 무모했지만 결과적으로 잘한 것이다.

## AUTOSAR 개발 과정
1) Configure System: 컴포넌트의 구성/연결 등을 정의함   
2) Implement Component: Configure system단계에서 구성한 컴포넌트들에 대한 코드 구현 등을 진행   
3) Extract ECU-Specific Information: 시스템 구성 정보로부터 특정 제어기 sw를 구현하기 위한 정보만을 추출함   
4) Configure ECU: 제어기 관련 설정을 진행함   
5) Generate Executable: 제어기에서 동작하는 실행파일을 만듦   
   
✅ RTE(Run Time Environment): 통신 middleware   

## AUTOSAR 플랫폼
✅ 같은 ECU내에선 RTE로 통신하면된다.   
<img src="https://github.com/user-attachments/assets/bef5b2ea-9265-41bf-b0e2-3cf58d056c6a" width="600" height="700">   
   
✅ S -> E -> MCAL layer순으로 따라야하지만 진짜 Real Time을 못 맞추겠으면 Application이 바로 Driver를 만져도됨.   
<img src="https://github.com/user-attachments/assets/e10e8d4a-ea27-41d8-8da4-c2788e33d3ce" width="600" height="400">   
   
✅ BSW
Basic Software Layers의 약자로써 여러 layer로 구성된다.   

## MCAL Generator
엠칼 제너레이터: 마이크로컨트롤러의 하드웨어 추상화 계층(MCAL) 드라이버를 자동으로 생성하는 도구   

# OS
## OSEK
✅ OSEK   
차량용 실시간 운영체제이다. AUTOSAR OS는 OSEK OS를 기반으로 만들어졌다.   
   
✅ 주요 서비스 기능   
task 관리, event 처리, resource(=mutax) 관리, interrupt 처리, alarm 처리, error 처리, system start-up/shutdown, hook 루틴   

## Task
✅ Task란?   
Task/Job: 추상적   
Process/Thread: 물리적   
   
✅ RT에는 hard와 soft가 있다.   
   
Sceduling   
✅ RT는 모두 priority scheduling 이다.   
✅ non-preemtive: 자기보다 우선순위가 높은 애가 오더라도 계속 실행된다.   
✅ Context Switching: context는 그 정보의 register를 건들여야하기때문에 아직도 어셈블리로 작성한다. 대부분의 os(mac, window, linux)는 C로 작성하는데 context switching은 어셈블리로 만든다. 
Process에 register set을 여러 개 만들어서 context switching 시간을 단축시킨다.   
   
✅ TaskHook   
디버깅이나 타이밍 정보 측정 등을 위하여 Task 동작 전후로 사용자가 작성하여 사용할 수 있는 루틴   
   
✅ 동작 방식   
동작 순서: PreTaskHook -> Task running -> PostTaskHook순으로 구현된다.   
이 한 과정이 running이다.   

## Event
✅ 어떤 Task간의 동작 순서를 정하기 위해 사용한다.   

## Interrupt
✅ exception, interrupct, trap

✅ Category 1 ISR(인터럽트 서비스 루틴)이 Category 2 ISR 보다 우선순위가 높아야한다.   

## Alarm
counter에 기반하며, 특정 시점에 도달하였을 경우 지정된 동작을 함으로써 반복적인 이벤트를 발생시킬 수 있도록 하는 os의 객체이다. 
관련 API 리스트가 여러 개 있다. (p.68)   

## Resource
✅ 우선순위가 다른 여러 task가 공유된 자원에 병행 접근하는 것을 조정   
종류: standard, internal, linked   
   
✅ 우선순위 역전현상   
낮은 우선순위의 작업이 높은 우선순위의 작업보다 먼저 실행되는 현상   

## Error
에러에도 여러 종류가 있다. (p.74)   

## System Start-up/Shutdown
✅ System Start-up   
시스템을 generation할 때 자동으로 시작하는 task 와 alarm 을 설정   
StartupHook routine 을 제공하여 사용자가 device driver 등을 초기화 할 수 있도록 함.   
   
✅ Shutdown   
fatal error -> Shutdown OS 작동 (ShutdownHook를 호출, hook이 종료되면 shutdown진행)   

# AUTOSAR OS
## AUTOSAR OS 개요
✅ Scalability Class   
SC1: OSEK OS를 포함한 기본 기능   
SC2: SC1 + Timing Protection 등   
SC3: SC1 + Memory Protection 등   
SC4: SC2 + SC3   
   
## Schedule Table
✅ Schedule Table의 정의   
고정적으로 정의되어 있는 expiry point 들의 집합   
Task를 실행하거나 Event를 세팅할 수 있다.   

## Stack Monitoring
결과적으론 효과가 없다.   
✅ 사용 목적   
Stack이 설정된 값보다 초과되어 사용되고 있지 않은 지 검사 (Overflow)   
설정으로 사용여부를 결정할 수 있음   
   
✅ 검사 대상   
Task, Category 2 ISR   
   
✅ 검사 시점   
context switching time 등에 하는데 에러 발생 후 발견되기까지 상당한 시간이 흐를 수 있다.   

## Protection Hook
OS에 의해 감지되는 심각한 에러의 발생을 알리기 위한 Interface 채널   
API 함수 형식을 갖는다.   
설정에 따라 사용 여부를 결정할 수 있다.   

✅ 사용 목적   
심각한 에러가 발생했을 때 OS 에 의해 호출 (내용은 User에 의해 작성)   
   
✅ 방법   
ProtectionHook 이 설정되지 않은 경우: OS 는 ShutdownOS 호출   
ProtectionHook 이 설정되어 있는 상태: OS 는 ProtectionHook을 호출하여 5가지 옵션 중에 하나를 선택하도록 한다.   
```c
return PRO_IGNORE;             // 아무 일도 하지 않음
return PRO_TERMINATETASKISR;   // 문제가 발생한 TASK/ISR 종료
return PRO_TERMINATEAPPL;      // 문제가 발생한 TASK/ISR이 속한 OS-application 종료
return PRO_TERMINATEARRL_RESTART; // 문제가 발생한 TASK/ISR이 속한 OS-application 재시작
return PRO_SHUTDOWN;           // OS 종료
```

## Timing Protection
✅ Timing Protection이란?   
Task 및 ISR 이 지정된 시간에 동작할 수 있도록 timing fault 가 발생 시 이에 대한 에러 처리를 수행   
   
✅ Timing fault 발생 원인   
RT 시스템에서 timing fault 는 Task 가 deadline 을 만족하지 못할 경우, 발생   

## OS-Application
✅ OS-Application   
OS-Application이란 OS object (Tasks, ISRs, Alarms, Schedule tables, Counters) 들의 모음이다. 
하나의 OS-Application 의 object 는 모두 동일한 core 에 있어야한다.   
   
<img src="https://github.com/user-attachments/assets/eccd2ea2-5b2a-4da4-93c3-caba92751586" width="600" height="300">   
   
✅ OS-Application 의 타입   
1. Trusted OS-Application   
다른 application 들에게 service 를 제공할 수 있음.   
Memory, OS 모듈의 API 에 무제한적인 접근 권한이 있을 수 있음.
   
2. Non-Trusted OS-Application   
제한적으로 API 와 hardware 자원에 접근할 수 있음.

## IOC
✅ IOC 란?   
정보 전달 방법   
1. Intra OS-Application communication   
2. Inter ECU communication (하나의 ECU 안에서 이루어지는 통신)   
3. Inter OS-Application communication (IOC) : OS 에 의한 방식   
   
✅ 사용 목적   
메모리가 보호되는 app 사이에서의 communication   
multi-core 를 지원하여 core 간 정보 교환을 수행할 수 있도록 한다.   
   
✅ IOC functionality   
1:1, N:1, N:M 통신이 지원됨.   

## Call Trusted Function
✅ 주요 기능   
Trusted OS-application 은 자기의 함수를 trusted function 으로 외부에 제공한다. non trusted os-application 은 CallTrustedFunction API 를 이용하여 Trusted OS-Application 의 함수를 호출한다.   
   
✅ 사용 제한   
동일한 Core 내의 application 간에만 사용할 수 있다.   

## Memory Protection
✅ MP 란?   
실행 프로그램(Task/ISR)이 특정 메모리 영역에 (stack, data, code)에 대하여 권한 없이 접근 못하도록 보호하는 서비스   

## Service Protection
✅ 사용 목적   
잘못된 OS Service (API) 사용에 의해 OS 에 문제가 생기는 것을 방지한다.   
OSEK 에서 포함하지 못한 case 에 OSEK OS 의 error status 를 적용한다.   
