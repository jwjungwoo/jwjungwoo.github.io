---
layout: single
title:  "C++ 프로그래밍"
categories: autoever
tag:
author_profile: false #true면 글 안에서 내 프로필 보여줌
sidebar:
    nav: "autoever"
#search: false
---

# C++ 기본개념

## C++ 특징

✅ c: 절차 지향적, 함수 지향적 (함수가 가장 중요함) -> c에서 가장 중요하다 생각하는 것: 함수포인터; 이유: "c가 객체 지향 프로그래밍처럼 다형성을 구현하기 어렵지만 함수 포인터가 이를 가능하게 해서 가장 중요하다 생각합니다."     
✅ c++: 객체 지향 프로그래밍(OOP: Object Orientied Programming)   
OOP 언어의 중요한 특징 4가지   
1. Encapsulation (캡슐화)   
2. Polymorphism (다형성)   
3. Inheritance (상속)   
4. Abstraction (추상화)   

## class

struct의 멤버변수는 항상 public이고 c++은 public과 private을 지정할 수 있다. 그리고 c++은 내부에 멤버 함수를 구현할 수 있다.   
또한 class의 선언은 메모리 사용 X, 정의: 메모리 사용 O
```c++
#include <iostream>
using namespace std;

class point_c {
public: // 접근지정자 
    int x; // 멤버변수
    int y;

    void set_x(int a) { // 멤버함수
        x = a;
    }
    void set_y(int b) {
        y = b;
    }
};

struct point_t {
    int x;
    int y;
    void set_x(int a) {
        x = a;
    }
    void set_y(int b) {
        y = b;
    }
};

int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);

    point_c c = { 11,22 }; // 가급적 만들면서 초기화하라

    cout << c.x << " " << c.y;
    return 0;
}
```   
   
✅ 어느 코드가 더 좋아 보일까?   
```c++
void drawRect(int x1, int y1, int x2, int y2);
```   
```c++
void drawRect(rectangle_t r);
```   
당연히 후자다.   

✅ 인자는 가급적 const를 붙이는게 좋다.   
```c
// c++
#include <stdio.h>

typedef struct _rectangle_t {
	int x1;
	int y1;
	int x2;
	int y2;
} rectangle_t;

int get_area_rect(const rectangle_t* r) { // ★★★
	return ((r->x2 - r->x1) * (r->y2 - r->y1));
}

void draw_rect(const rectangle_t* r) { // ★★★
	printf("cc 사각형을 그렸어요.\r\n");
}


int main(void) {
	rectangle_t r = {10, 10, 20, 20};
	int area = get_area_rect(&r); // ★★★
	printf("사각형의 넓이는 %d입니다.\r\n", area);
	draw_rect(&r); // ★★★
	return 0;
}
```   

c도 구조체 내에 함수 포인터써서 멤버함수를 만들 수 있다. 다만, 그렇게 잘 쓰이진 않는다.   
```c
//c
#include <stdio.h>

int mul(int x, int y) {
	return x * y;
}

typedef struct _rectangle_t {

	int x1;
	int y1;
	int x2;
	int y2;

	int(*t_mul)(int a, int b);

} rectangle_t;

int main(void) {
	rectangle_t r = { 10, 10, 20, 20 };
	int(*pp) = &mul;
	
	r.t_mul = pp;

	printf("두 수의 곱은 %d입니다.\r\n", r.t_mul(2, 3));
	return 0;
}
```

## 클래스내의 static 변수(=클래스 변수) 및 함수

✅ 클래스 변수란?   
```c++
#include <iostream>

class Foo {
public:
	int a;
	static int x; // (1) 정적 멤버 변수 = 클래스 변수 = static 

	void func1() {};

	static void sfunc1() { // (2) 정적 멤버 함수
		std::cout << "sfunc1()" << std::endl;
	}
};

int Foo::x = 12; // (3) 정적 변수(=클래스변수)의 초기화 방법

int main() {
	//a = 11; // (4) 에러! 인스턴스가 없기 때문에 에러!

	std::cout << "Foo::x=" << Foo::x << std::endl;
	// (2) ok 정적 변수는 객체가 없어도 (=인스턴스가 없어도) 가능하다

	Foo::sfunc1();

	Foo::x = 33;
	std::cout << "Foo::x=" << Foo::x << std::endl;

	Foo foo;
	foo.a = 11;

	return (0);
}
```
   
✅ 멤버 변수와 클래스 변수의 차이점   
출력 뭐 나올지 생각해보기   
```c++
#include <iostream>
using namespace std;

class Fishbun {
public:
	int cnt1; // cnt1은 붕어빵 각각에 존재하나
	static int cnt2; // cnt2는 붕어빵 틀에 존재한다.

	Fishbun() : cnt1{ 0 }
	{
		++cnt1;
		++cnt2;
	}
};

int Fishbun::cnt2 = 0;

int main() {
	Fishbun f1;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	Fishbun f2;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	Fishbun f3;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	return (0);
}
```

## class 객체 생성

✅ 예시
```c++
#include <iostream>
#include <cstdlib>
class Sample {
public:
	int a;
	int b;
};

int main(void) {
	Sample s1; // ok. 스택에 할당
	Sample s2(); // (1) warning!! 경고 발생! 객첸지 생성잔지 헷갈림

	Sample* s3 = new Sample; // ok
	s3->a = 11;
	std::cout << "s3(a, b)=(" << s3->a << "," << s3->b << ")" << std::endl;

	Sample* s4 = new Sample(); // ok
	s4->a = 33;
	std::cout << "s4(a, b)=(" << s4->a << "," << s4->b << ")" << std::endl; // (2)

	return (0);
}
```

## this 포인터

✅ this는 자기 자신의 참조를 돌려준다.   
```c
#include <iostream>

class Point {
private:
	int x{ 0 };
	int y{ 0 };

public:
	void set(int a, int b) {
		x = a;
		y = b;
		std::cout << this << std::endl;
	}
};

int main() {
	Point pt1;
	Point pt2;

	std::cout << &pt1 << std::endl;
	std::cout << &pt2 << std::endl;

	pt1.set(11, 22);
	pt2.set(33, 44);
	return 0;
}
```   
   
✅ this return   
```c++
#include <iostream>

class Counter {
public:
	int count;
public:
	void reset(int count = 0) {
		this->count = count;
	}
	Counter* increment() {
		++count;
		return this;
	}
	Counter& decrement() {
		--count;
		return *this;
	}
};

int main() {
	Counter c;
	c.reset();
	c.increment()->increment()->increment()->increment();

	std::cout << c.count << std::endl;
	c.decrement().decrement().decrement();
	std::cout << c.count << std::endl;

	return 0;
}
```   
   
✅ 근데 이거 뭐에다 써? cout이 이런 형태로 되어있다.   
```c++
std::cout<<”a”<<”b”<<”c”;
std::cout.operator<<(”A”)
return *this
// 즉 std::cout을 다시 반환
```

## namespace
✅ 범위는 줄여쓰면 좋다.   
```c
#include <iostream>
using std::cout;
using std::cin;

namespace audio {
	void init() {
		cout << "hello\n";
	}
}
namespace video {
	void init() {
		cout << "hello\n";
	}
}

using namespace audio;

int main() {
	init();
	video::init();
	return 0;
}
```

## 예외 처리
✅ 예외 처리   
오류를 처리하기 위한 구문 try, catch, throw를 지원한다.   

## 소수점 자리수 조정
✅ 개념     
cout으로 출력시 기본적으로 6자리에 맞춰서 출력해주는데   
간혹 자릿수를 짧게 혹은 길게 바꿔줘야 할 필요가 있다.   
이에 대해 알아보자.   
```c++
#include <iostream>
using namespace std;

int main() {
	double a = 12345.12345;
	cout << a << endl; // 그냥 출력하면 얼마가 나올까? 12345.12345? no
	// 12345.1가 나온다. 왜요? 6자리고 고정되어 있다.

	//실수에서 자릿수를 조절하고 싶을때
	cout.precision(7); // 12345.12 출력된다. (n)개를 출력한다.
	cout << a << endl;

	double b = 3.1415;
	cout << b << endl; // 당연히 3.1415 전부다 출력되는데,
	cout.precision(3); // 나는 그냥 3.14까지만 출력하고 싶다면, 정밀도 재조정
	cout << b << endl; // 3.14 출력

	double c = 2.7182818;
	cout.fixed; // 기존 설정을 그대로 사용하고 싶다면 fixed
	// preciosn(3)를 써줘도 되지만 불편하니까.
	cout << c << endl;  // 2.72 출력

	// fixed를 해제하려면?
	// 정밀도를 재조정해도 되고
	cout.unsetf(ios::fixed);
	cout << c << endl; // 해제되어 2.72 출력(마지막 0.008은 반올임 되었다.)

	double d = 12345.12345;
	cout << d << endl; // 12345.1이 출력되는건 맞는데, 지수형태로 출력한다. 1.23e+04 출력

	cout.precision(8); // 다시 설정해 준다.
	//std::cout.unsetf(std::ios::scientific); //지수 출력
	cout << d << endl; // 12345.123 출력

	return (0);
}
```

## 함수 오버로딩

✅ 오버라이딩과 오버로딩의 차이   
오버라이딩은 상속받은 함수와 이름이 같아도 재정의할 수 있다는 것이다. 오버로딩은 함수 이름이 같고 인자가 다른 것이다.   

# 데이터 타입과 변수 (type and variable)

## 유니폼 초기화 (Uniform initialization)
요건 쓸만하다.   
```c++
struct point {
	int x;
	int y;
};

class rect {
public:
	int x1;
	int y1; // x2,y2를 넣어 2점을 만들어야 하지만, 
	// 클래스 초기화만 볼것이므로 x2, y2는 뺐다.
	rect(int a, int b) {
		x1 = a;
		y1 = b;
	}
};

int main(void) {
	// 초기화 방법이 다양해서 헷갈린다.
	int          a1 = 0;			//기본 데이터형은 =연산자로 초기화, 괄호가 없다.
	struct point b1 = { 0,0 };		// 구조체는 중괄호
	int          c1[3] = { 11,22,33 };	// 배열은 중괄호
	rect         r1(1, 2);				// 클래스는 소괄호

	int          a2 = {0};
	struct point b2 = { 0,0 };
	int          c2[3] = { 11,22,33 };
	rect         r2 = {1,2};

	int          a3{ 0 };
	int			 a4(11); // not good 생성자 스타일로 초기화 헷갈리니까 위에껄 쓰자
	struct point b3 { 0, 0 };
	//struct point b4(1, 2); // error
	int          c3[3]{ 11,22,33 };
	rect         r3{ 1,2 };
	rect         r4( 1,2 );// 구조체는 안되지만 클래스는 가능
	return 0;
}
```

## bool
c에서 bool은 실제론 int형이다.   
