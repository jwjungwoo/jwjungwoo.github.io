---
layout: single
title:  "C++ 프로그래밍"
categories: autoever
tag:
author_profile: false #true면 글 안에서 내 프로필 보여줌
sidebar:
    nav: "autoever"
#search: false
---

# C++ 기본개념

## OOP

✅ c: 절차 지향적, 함수 지향적 (함수가 가장 중요함) -> c에서 가장 중요하다 생각하는 것: 함수포인터; 이유: "c가 객체 지향 프로그래밍처럼 다형성을 구현하기 어렵지만 함수 포인터가 이를 가능하게 해서 가장 중요하다 생각합니다."     
✅ c++: 객체 지향 프로그래밍(OOP: Object Orientied Programming)   
OOP 언어의 중요한 특징 4가지   
1. Encapsulation (캡슐화)   
2. Polymorphism (다형성)   
3. Inheritance (상속)   
4. Abstraction (추상화)   

## 다형성
✅ OOP에서 다형성(Polymorphism)의 의미   
🔹 하나의 형이 다른 형을 가질수 있다.   
다음 코드에서 sound()는 다른 형태들을 지닌다.   
```c++
class Animal:
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "멍멍"

class Cat(Animal):
    def sound(self):
        return "야옹"

animals = [Dog(), Cat()]
for animal in animals:
    print(animal.sound())  # Dog와 Cat에 따라 다른 출력
```
## interface
✅ sw의존도 낮추기   
🔹 callback의 단점: receiver가 sender에게 약속을 강제할 수 없다. ex. 난 void (*)() 이렇게 왔으면 좋겠는데 상대편 개발자가 int (*)(int,int) 이렇게 만들어서 나도 버그 걸렸음.   
반면 interface를 구현하면 약속을 강제하기 때문에 이런 문제가 안 생김.   
🔹 interface: 순수 가상함수로 구현된 클래스를 상속 받는다.   
   
✅ 순수 가상 함수로만 만들어진 클래스를 interface라고 한다.   

## interface가 만들어진 이유
✅ 스마트 폰 개발의 문제점: 새로운 모델이 등장할때마다 코드를 계속 수정해야 한다.   
```c++
#include <iostream>

class LandLinePhone {
public:
	void landlineCall() const {
		std::cout << "유선 전화를 걸다." << std::endl;
	}
};

class CellPhone {
public:
	void cellPhoneCall() const {
		std::cout << "무선 전화를 걸다." << std::endl;
	}
};

class SmartPhone {
public:
	void smartPhoneCall() const {
		std::cout << "영상 전화를 걸다." << std::endl;
	}
};


class Person {
public:
	void makeCall(const LandLinePhone* phone) const {
		phone->landlineCall();
	}

	void makeCall(const CellPhone* phone) const { 
		phone->cellPhoneCall();
	}

	void makeCall(const SmartPhone* phone) const { // ★★★ 또 늘어난다.
		phone->smartPhoneCall();
	}
};

int main() {
	Person person;

	LandLinePhone landLinePhone;
	person.makeCall(&landLinePhone);

	CellPhone cellPhone;
	person.makeCall(&cellPhone);

	SmartPhone smartPhone;
	person.makeCall(&smartPhone);

	return 0;
}
```
   
✅ 미래에 새로운 전화기가 출시된다면?   
새로운 전화기가 등장할때마다 새로운 클래스를 만드는것은 납득이 되지만   
문제는 기존 코드도 매번 수정해야 한다는 점이다.   
```c++
class Person {
	void makeCall(const LandLinePhone* phone) const {
	void makeCall(const CellPhone* phone) const { 
	void makeCall(const SmartPhone* phone) const { // ★★★ 또 늘어난다.
	// ★★★ 또 늘어난다.
	// ★★★ 또 늘어난다.
	void makeCall(const ???* phone) const { // 타입을 알수도 없다. 아직 만들어지지도 않았으니까
};
```

물론 상속도 있다. 하지만, 미래 개발자가 구현해야하는 함수를 실수로 잊을 수도 있기때문에 강제성을 부가할 수 있다.   
```c++
#include <iostream>

class IPhone {
public:
	virtual ~IPhone() = default; // 기본 생성자나 소멸자 만들면 컴파일러가 "너 왜 내꺼 있는데 굳이 새로 만들어"라고 뭐라한다. 그래서 인자 넣거나 특정 작동시킬거 아니면 default라고 쓰자.
	virtual void call() const = 0; // (1) 전화기란 전화기는 모두 이 규칙을 따르게 강제 하겠다.
};

class LandLinePhone : public IPhone {
public:
	void call() const override{
		std::cout << "유선 전화를 걸다." << std::endl;
	}
};

class CellPhone : public IPhone {
public:
	void call() const override {
		std::cout << "무선 전화를 걸다." << std::endl;
	}
};

class SmartPhone : public IPhone {
public:
	void call() const override {
		std::cout << "영상 전화를 걸다." << std::endl;
	}
};


class Person {
public:
	void makeCall(const IPhone* phone) const {
		phone->call();
	}
};

int main() {
	Person person;

	LandLinePhone landLinePhone;
	person.makeCall(&landLinePhone);


	return 0;
}
```

## class

struct의 멤버변수는 항상 public이고 c++은 public과 private을 지정할 수 있다. 그리고 c++은 내부에 멤버 함수를 구현할 수 있다.   
또한 class의 선언은 메모리 사용 X, 정의: 메모리 사용 O
```c++
#include <iostream>
using namespace std;

class point_c {
public: // 접근지정자 
    int x; // 멤버변수
    int y;

    void set_x(int a) { // 멤버함수
        x = a;
    }
    void set_y(int b) {
        y = b;
    }
};

struct point_t {
    int x;
    int y;
    void set_x(int a) {
        x = a;
    }
    void set_y(int b) {
        y = b;
    }
};

int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);

    point_c c = { 11,22 }; // 가급적 만들면서 초기화하라

    cout << c.x << " " << c.y;
    return 0;
}
```   
   
✅ 어느 코드가 더 좋아 보일까?   
```c++
void drawRect(int x1, int y1, int x2, int y2);
```   
```c++
void drawRect(rectangle_t r);
```   
당연히 후자다.   

✅ 인자는 가급적 const를 붙이는게 좋다.   
```c
// c++
#include <stdio.h>

typedef struct _rectangle_t {
	int x1;
	int y1;
	int x2;
	int y2;
} rectangle_t;

int get_area_rect(const rectangle_t* r) { // ★★★
	return ((r->x2 - r->x1) * (r->y2 - r->y1));
}

void draw_rect(const rectangle_t* r) { // ★★★
	printf("cc 사각형을 그렸어요.\r\n");
}


int main(void) {
	rectangle_t r = {10, 10, 20, 20};
	int area = get_area_rect(&r); // ★★★
	printf("사각형의 넓이는 %d입니다.\r\n", area);
	draw_rect(&r); // ★★★
	return 0;
}
```   

c도 구조체 내에 함수 포인터써서 멤버함수를 만들 수 있다. 다만, 그렇게 잘 쓰이진 않는다.   
```c
//c
#include <stdio.h>

int mul(int x, int y) {
	return x * y;
}

typedef struct _rectangle_t {

	int x1;
	int y1;
	int x2;
	int y2;

	int(*t_mul)(int a, int b);

} rectangle_t;

int main(void) {
	rectangle_t r = { 10, 10, 20, 20 };
	int(*pp) = &mul;
	
	r.t_mul = pp;

	printf("두 수의 곱은 %d입니다.\r\n", r.t_mul(2, 3));
	return 0;
}
```

## 클래스내의 static 변수(=클래스 변수) 및 함수

✅ 클래스 변수란?   
```c++
#include <iostream>

class Foo {
public:
	int a;
	static int x; // (1) 정적 멤버 변수 = 클래스 변수 = static 

	void func1() {};

	static void sfunc1() { // (2) 정적 멤버 함수
		std::cout << "sfunc1()" << std::endl;
	}
};

int Foo::x = 12; // (3) 정적 변수(=클래스변수)의 초기화 방법

int main() {
	//a = 11; // (4) 에러! 인스턴스가 없기 때문에 에러!

	std::cout << "Foo::x=" << Foo::x << std::endl;
	// (2) ok 정적 변수는 객체가 없어도 (=인스턴스가 없어도) 가능하다

	Foo::sfunc1();

	Foo::x = 33;
	std::cout << "Foo::x=" << Foo::x << std::endl;

	Foo foo;
	foo.a = 11;

	return (0);
}
```
   
✅ 멤버 변수와 클래스 변수의 차이점   
출력 뭐 나올지 생각해보기   
```c++
#include <iostream>
using namespace std;

class Fishbun {
public:
	int cnt1; // cnt1은 붕어빵 각각에 존재하나
	static int cnt2; // cnt2는 붕어빵 틀에 존재한다.

	Fishbun() : cnt1{ 0 }
	{
		++cnt1;
		++cnt2;
	}
};

int Fishbun::cnt2 = 0;

int main() {
	Fishbun f1;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	Fishbun f2;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	Fishbun f3;
	cout << f1.cnt1 << "," << Fishbun::cnt2 << "\n";

	return (0);
}
```

## class 객체 생성

✅ 예시
```c++
#include <iostream>
#include <cstdlib>
class Sample {
public:
	int a;
	int b;
};

int main(void) {
	Sample s1; // ok. 스택에 할당
	Sample s2(); // (1) warning!! 경고 발생! 객첸지 생성잔지 헷갈림

	Sample* s3 = new Sample; // ok
	s3->a = 11;
	std::cout << "s3(a, b)=(" << s3->a << "," << s3->b << ")" << std::endl;

	Sample* s4 = new Sample(); // ok
	s4->a = 33;
	std::cout << "s4(a, b)=(" << s4->a << "," << s4->b << ")" << std::endl; // (2)

	return (0);
}
```

## this 포인터

✅ this는 자기 자신의 참조를 돌려준다.   
```c
#include <iostream>

class Point {
private:
	int x{ 0 };
	int y{ 0 };

public:
	void set(int a, int b) {
		x = a;
		y = b;
		std::cout << this << std::endl;
	}
};

int main() {
	Point pt1;
	Point pt2;

	std::cout << &pt1 << std::endl;
	std::cout << &pt2 << std::endl;

	pt1.set(11, 22);
	pt2.set(33, 44);
	return 0;
}
```   
   
✅ this return   
```c++
#include <iostream>

class Counter {
public:
	int count;
public:
	void reset(int count = 0) {
		this->count = count;
	}
	Counter* increment() {
		++count;
		return this;
	}
	Counter& decrement() {
		--count;
		return *this;
	}
};

int main() {
	Counter c;
	c.reset();
	c.increment()->increment()->increment()->increment();

	std::cout << c.count << std::endl;
	c.decrement().decrement().decrement();
	std::cout << c.count << std::endl;

	return 0;
}
```   
   
✅ 근데 이거 뭐에다 써? cout이 이런 형태로 되어있다.   
```c++
std::cout<<”a”<<”b”<<”c”;
std::cout.operator<<(”A”)
return *this
// 즉 std::cout을 다시 반환
```

## namespace
✅ 범위는 줄여쓰면 좋다.   
```c
#include <iostream>
using std::cout;
using std::cin;

namespace audio {
	void init() {
		cout << "hello\n";
	}
}
namespace video {
	void init() {
		cout << "hello\n";
	}
}

using namespace audio;

int main() {
	init();
	video::init();
	return 0;
}
```

## 예외 처리
✅ 예외 처리   
오류를 처리하기 위한 구문 try, catch, throw를 지원한다.   

## 소수점 자리수 조정
✅ 개념     
cout으로 출력시 기본적으로 6자리에 맞춰서 출력해주는데   
간혹 자릿수를 짧게 혹은 길게 바꿔줘야 할 필요가 있다.   
이에 대해 알아보자.   
```c++
#include <iostream>
using namespace std;

int main() {
	double a = 12345.12345;
	cout << a << endl; // 그냥 출력하면 얼마가 나올까? 12345.12345? no
	// 12345.1가 나온다. 왜요? 6자리고 고정되어 있다.

	//실수에서 자릿수를 조절하고 싶을때
	cout.precision(7); // 12345.12 출력된다. (n)개를 출력한다.
	cout << a << endl;

	double b = 3.1415;
	cout << b << endl; // 당연히 3.1415 전부다 출력되는데,
	cout.precision(3); // 나는 그냥 3.14까지만 출력하고 싶다면, 정밀도 재조정
	cout << b << endl; // 3.14 출력

	double c = 2.7182818;
	cout.fixed; // 기존 설정을 그대로 사용하고 싶다면 fixed
	// preciosn(3)를 써줘도 되지만 불편하니까.
	cout << c << endl;  // 2.72 출력

	// fixed를 해제하려면?
	// 정밀도를 재조정해도 되고
	cout.unsetf(ios::fixed);
	cout << c << endl; // 해제되어 2.72 출력(마지막 0.008은 반올임 되었다.)

	double d = 12345.12345;
	cout << d << endl; // 12345.1이 출력되는건 맞는데, 지수형태로 출력한다. 1.23e+04 출력

	cout.precision(8); // 다시 설정해 준다.
	//std::cout.unsetf(std::ios::scientific); //지수 출력
	cout << d << endl; // 12345.123 출력

	return (0);
}
```

## 함수 오버로딩

✅ 오버라이딩과 오버로딩의 차이   
오버라이딩은 상속받은 함수와 이름이 같아도 재정의하는 것이다. 오버로딩은 함수 이름이 같고 인자가 다른 것이다. 다만 오버로딩에서 반환타입으로는 구분할 수 없다.   

## 네임 맹글링

✅ 네임 맹글링 (name mangling)   
컴파일러는 인자만 보고 두 함수가 다른 것을 안다.   
```c++
squre(3);
square(3.1);
```
컴파일러가 이름을 슬쩍 바꿔준다.   
실제로 square_int 이렇게 바꿔주는건 아니고, 컴파일러가 알아서 바꿔준다.   
```c++
int square_○○○(int a) {}
double square_●●●(double a) {}
// square@@YAHH@Z ← square_○○○
// square@@YANN@Z ← square_●●●
```

## inline 함수
inline함수는 매크로처럼 코드레벨에서 치환된다. 따라서 함수 호출과정(스택에 넣고 빼고)가 없어서 훨씬 빠르다. 
즉, 성능, 효율성이 좋다. 코드가 간단하다면 인라인 함수를 쓰자. 다만 그냥 비슷비슷하다 하셨다.

## 함수 템플릿

```c++
#include <iostream>

template<typename Hey>
Hey square(Hey a) {
	return (a * a);
}
// Hey에 타입을 보내주면 Hey를 채워준다.
// 위의 코드는 함수가 아니야. 템플릿이야

int main() {
	int a = square(3); // 이것도 동작하지만 ★★이건 함수가 아니야, 함수 템플릿이야
	double b = square(3.2);

	std::cout << a << std::endl;
	std::cout << b << std::endl;

	int c = square<int>(2); // 이렇게 적자!! 함수를 만들어 준다! 템플릿 인스턴스화
	double d = square<double>(3.2);
	std::cout << c << std::endl;
	std::cout << d << std::endl;

	return 0;
}
```

## for_each

```c++
#include <iostream>
#include <algorithm>
using namespace std;

void print_one(int one) {
	cout << one << "\n";
}

int a[5] = { 3,2,1,3,2 };
int main() {

	for_each(a, a + 5, print_one);
	return 0;
}
```   

## reference

✅ C에는 없고 C++에만 있는 reference   
가급적이면 reference를 쓰자.   
   
✅ pointer vs reference   
pointer(참조)는 null값이 들어갈 수 있으나 이는 문제를 일으킬 수 있음. 또한 가리키는 대상이 바뀔 수 있음. 반면 reference는 초기화부터 값을 지정해줘야 생성됨. 
또한 가리키는 대상 못 바꿈. 따라서 안정적임. 물론 pointer도 const를 붙임으로써 reference를 따라할 수 있으나 그냥 reference 쓰는게 좋다.   
   
✅ 모듈간 의존도   
하나를 고쳐도 나머지는 영향을 최대한 안 받게 해야하므로 전역변수 사용은 최대한 지양해야한다. 따라서 reference 사용하는게 중요   
   
✅ C++에서 call by reference를 pass by reference라고 한다.   
하나의 주소에 이름이 두 개 생겼다 보면됨.   
```c++
#include <iostream>
using namespace std;

int main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);

	int k = 11;
	int* pa = &k;
	*pa = 22;
	cout << k << "\n";

	int& ra = k; // C++에는 reference 라는게 존재한다. 
	ra = 33;
	cout << ra << k << *pa << "\n";

	cout << &pa << "\n" << &ra << "\n" << &k << "\n"; // 포인터는 주소가 다르나 ra와 k의 주소는 값다. C++의 reference는 한 주소를 원래 변수와 reference가 나눠쓴다.

	return 0;
}
```   
✅ reference를 함수인자로 받을 땐 뭐를 써야할까?   
```c++
#include <iostream>

void bts(int  x) { x += 1; } // (1) Call by value
void exo(int* p) { *p += 1; } // (2) Call by reference 참조 버전
void ses(int& r) { r += 1; } // (3) Call by reference 참조 버전...? 위에도 참조 아래도 참조?

int main() {
	int a = 11;
	int b = 22;
	int c = 33;

	bts(a); // (1)
	exo(&b); // (2)
	//ses(★); // (3) ★는 무엇으로 적어야 할까?
	ses(c);

	std::cout << "a=" << a << std::endl;
	std::cout << "b=" << b << std::endl;
	std::cout << "c=" << c << std::endl;

	return (0);
}
```   
✅ swap함수 만들기   
```c++
#include <iostream>
using namespace std;

void swap(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
	return;
}
int main() {
	int a = 11, b = 22;
	swap(a, b);
	cout << a << " " << b << "\n";
	swap(a, b);
	cout << a << " " << b;
	return (0);
}
```
✅ const 써주기 중요!!!!!!!   
```c++
#include <iostream>

typedef struct _point_t {
	int x;
	int y;
} point_t;

void print_point(const point_t& point) { // 수정되지 않는다면 const
	std::cout << "point(x,y)=(" << point.x << "," << point.y << ")" << std::endl;
}

int main() {
	point_t pt1 = { 11,22 };
	print_point(pt1); // pt1의 복사본이 전달된다. call by value

	point_t pt2 = { 33,44 };
	print_point(pt2);

	return (0);
}
```   
✅ 값에 의한 반환, 참조에 의한 반환 (return by value vs return by reference)   
```c++
class Point {
public:
	int x;
	int y;
};

Point pt = { 11,22 };

Point f1() { // return by value
	return pt; // pt가 리턴되는게 아니라
	// 리턴용 임시객체(temporary boject)가 만들어서 돌려줌
	// 정확히는 복사 생성자가 호출됨
}

Point& f2() { // return by reference
	return pt; // 진짜 pt를 돌려줌
}

int main() {
	//f1().x = 11; // 리턴용임시객체.x = 11; // lvalue가 될수 없어 컴파일 에러
	f2().x = 22; // pt.x= 22 // 이건 된다.
}
```   
✅ template으로 만들기   
기존의 swap함수를 좀더 범용적으로 만들어 보자.   
int 타입만 swap 할수 있는데, int, char, double도 swap할수 있게 바꿔보자.   
   
내가 만든 유용한 유틸리니까 namesapce를 적용해보았다.   
int말고 다른 타입도 변환하고 싶을때 template을 사용하면 매우매우 편리하다.   
inline을 사용하면 좀더 성능향상을 가져올수 있다.   
```c++
#include <iostream>

namespace my_util {
	template <class T> 
	inline void swap(T& a, T& b) {
		T temp = a;
		a = b;
		b = temp;
	}
}

int main() {
	int a = 11;
	int b = 22;
	my_util::swap<int>(a, b);		// pass by reference
	std::cout << "(a,b)=(" << a << "," << b << ")" << std::endl;

	double c = 12.34;
	double d = 23.45;
	my_util::swap<double>(c, d);
	std::cout << "(c,d)=(" << c << "," << d << ")" << std::endl;
	return (0);
}
```

# 데이터 타입과 변수 (type and variable)

## 유니폼 초기화 (Uniform initialization)
요건 쓸만하다.   
```c++
struct point {
	int x;
	int y;
};

class rect {
public:
	int x1;
	int y1; // x2,y2를 넣어 2점을 만들어야 하지만, 
	// 클래스 초기화만 볼것이므로 x2, y2는 뺐다.
	rect(int a, int b) {
		x1 = a;
		y1 = b;
	}
};

int main(void) {
	// 초기화 방법이 다양해서 헷갈린다.
	int          a1 = 0;			//기본 데이터형은 =연산자로 초기화, 괄호가 없다.
	struct point b1 = { 0,0 };		// 구조체는 중괄호
	int          c1[3] = { 11,22,33 };	// 배열은 중괄호
	rect         r1(1, 2);				// 클래스는 소괄호

	int          a2 = {0};
	struct point b2 = { 0,0 };
	int          c2[3] = { 11,22,33 };
	rect         r2 = {1,2};

	int          a3{ 0 };
	int			 a4(11); // not good 생성자 스타일로 초기화 헷갈리니까 위에껄 쓰자
	struct point b3 { 0, 0 };
	//struct point b4(1, 2); // error
	int          c3[3]{ 11,22,33 };
	rect         r3{ 1,2 };
	rect         r4( 1,2 );// 구조체는 안되지만 클래스는 가능
	return 0;
}
```

## bool
c에서 bool은 실제론 int형이다.   

# class
## 정보 은닉과 접근지정자 (Data Hiding and Access Modifier)
✅ 멤버 변수에 외부접근을 허용하면(=노출하면) 잘못된 값이 저장될 우려가 있다.   
따라서 접근지정자를 (외부에서 접근 못하게) 범위가 가장 좁은 private으로 바꿔준다.   
```c
#include <iostream>
#include <string>

class Person {
public:
	std::string name= ""; // 항상 초기화 시키는 습관을 들이자.

private:
	int age= 0;

public:
	void setAge(int a) {
		age = a;
	}
	int getAge() const{
		return age;
	}
};

int main() {
	Person p;
	p.name = "정예림";
	p.setAge(19);
	std::cout << p.name << "의 나이는 " << p.getAge() << "입니다." << std::endl;
	return 0;
}
```

## 데이터 무결성: setter 함수를 잘 만들자.

✅ 데이터 무결성이란?   
데이터 무결성이란   
- 몸무게가 음수라거나   
- 나이가 음수라거나   
와 같이 데이터가 이상한 상태를 갖는 것을 말한다.   
   
클래스를 만들때   
- 멤버 변수에 직접 접근하게 하는 것보다   
- setter getter함수를 사용하면   
데이터 무결성이 보장이 더 잘된다.

```c++
#include <iostream>
#include <string>

class Person {
public:
	std::string name= ""; // 항상 초기화 시키는 습관을 들이자.

private:
	int age= 0;

public:
	void setAge(int val) {
		if (val >= 1 && val < 150) { // (1)
			age = val;
		}
		else {
			printf("나이 입력값이 %d로 잘못되었습니다.\r\n", val);
		}
	}
	int getAge() const{
		return age;
	}
};

int main() {
	Person p;
	p.name = "정예림";
	p.setAge(190);
	std::cout << p.name << "의 나이는 " << p.getAge() << "입니다." << std::endl;
	return 0;
}
```

## 생성자 소멸자
```c++
// 기본문법
#include <iostream>

class Person {
private:
	std::string name;
	int age;
public:
	Person() {
		name = "abc";
		age = 83;
		std::cout << "created\n";
	}
	Person(std::string a, int b) {
		name = a;
		age = b;
	}
	~Person() {
		std::cout << "deleted\n";
	}
};

int main() {
	Person p1;
	Person p2("apple", 33);
	std::cout << "main running\n";
}
```

## private, protected, public
private: 하위 클래스에서 대입연산자와 setter로 초기화 불가    
protected: 하위 클래스에서 setter로만 초기화 가능   
public: 하위 클래스에서 대입연산자와 setter로 초기화 가능   

## class 상속시 생성 소멸 순서
✅ 생성: 상위 클래스 생성된 다음에 하위 클래스가 생성됨   
✅ 소멸: 하위 클래스 소멸된 다음에 상위 클래스가 소멸됨   

## 하위 객체를 생성시, 상위 객체 생성자도 신경써야 한다
✅ 상속관계시에 Student 객체를 만들때 문제가 생기는 경우   
```c++
#include <string>

class Person {
public:
	std::string name;
	int age;
	// 기본 생성자가 날라갔죠
	Person(const std::string& name, int age)  // (1) 요렇게 오버로딩 해줌, 디폴트 생성자가 사라짐
		: name{ name }, age{ age }
	{

	}
};

class Student : public Person {
public:
	std::string major;
	int number; // 학번

	Student(std::string major, int number) : // (3)과 같은 생성자를 추가해야 되는데
		major{ major }, number{number}
	{ // (4) 여기서 상위 객체의 디폴트 생성자를 호출하려고 한다. error 발생

	}
};

int main(void) {
	Person p2 = { "정상훈", 11 }; // (1) Person은 아무런 문제가 없는데...
	Student s1 = { "컴퓨터공학", 92 }; // (2) Student를 이렇게 만드려다 보니
	return (0);
}
```
이유는 Student 생성시 Person이 먼저 생성되는데 Person은 생성되려면 name, age를 꼭 받아야하기때문.   
   
✅ 해결 방법 및 결론 (Solution & Conclusion)   
```c++
#include <iostream>
#include <string>

class Person {
public:
	std::string name;
	int age;
};

class Student : public Person {
public:
	std::string major;
	int number; // 학번

	Student(std::string major, int number, std::string name, int age) :
		Person{ name, age }, // (1) 주의 상위객체 생성자를 먼저 호출해야 한다.
		major{ major }, number{ number } // (2) 이후에 내 객체를 초기화 하자.
	{

	}
};

class Professor : public Person {
public:
	std::string major;
	int grade;

	Professor(std::string major, int grade, std::string name, int age) :
		Person{ name, age }, // (1) 여기도 마찬가지
		major{ major }, grade{ grade } // (2) 이후에 내 객체를 초기화 하자.
	{

	}
};

int main(void) {
	Student s1 = { "computer", 12, "정상훈", 22 };
	Professor p1 = { "history", 1, "정예림", 33 };
	std::cout << s1.major << "," << s1.number << "," << s1.name << "," << s1.age << std::endl;
	std::cout << p1.major << "," << p1.grade << "," << p1.name << "," << p1.age << std::endl;
	return (0);
}
```

## 가상함수

✅ 왜 상위 객체의 draw() 함수를 호출하냐? 내가 하고싶은건 이거야!   
다음 코드를 돌리면 "일반적인 도형을 그려요."만 두 번 호출됨.   
<img src="https://github.com/user-attachments/assets/014a188f-f6f5-4fef-9706-ca87fc385f97" width="300" height="100">   
```c++
#include <iostream>
using namespace std;

class Shape { // 기반 클래스: Shape
public:
    void draw() const { // 가상 함수 선언
        cout << "일반적인 도형을 그려요." << endl;
    }

    virtual ~Shape() {} // 가상 소멸자
};


class Rectangle : public Shape { // 파생 클래스: Rectangle
public:
    
    void draw() const { // 가상 함수 재정의
        cout << "사각형을 그려요." << endl;
    }
};

class Circle : public Shape { // 파생 클래스: Circle
public:
    
    void draw() const { // 가상 함수 재정의
        cout << "원을 그려요." << endl;
    }
};

int main() {
    // 기본 클래스 포인터 배열
    Shape* shapes[2];

    shapes[0] = new Rectangle();
    shapes[1] = new Circle();

    // 각 객체의 draw() 호출 (동적 바인딩)
    // 실제 객체 타입에 따라 적절한 draw() 호출
    shapes[0]->draw();
    shapes[1]->draw();

    delete shapes[0];
    delete shapes[1];


    return 0;
}
```   
   
반면 아래 코드는 상속받은 클래스만 동작함   
<img src="https://github.com/user-attachments/assets/deb0b282-af4d-4aaa-9d07-55eae40a5521" width="300" height="100">   
```c++
#include <iostream>
using namespace std;

class Shape { // 기반 클래스: Shape
public:
    virtual void draw() { // 가상 함수 선언
        cout << "일반적은 도형을 그려요." << endl;
    }

    virtual ~Shape() {} // 가상 소멸자
};


class Rectangle : public Shape { // 파생 클래스: Rectangle
public:

    virtual void draw() override { // 가상 함수 재정의
        cout << "사각형을 그려요." << endl;
    }
};

class Circle : public Shape { // 파생 클래스: Circle
public:

    virtual void draw() override { // 가상 함수 재정의
        cout << "원을 그려요." << endl;
    }
};

int main() {
    // 기본 클래스 포인터 배열
    Shape* shapes[2];

    shapes[0] = new Rectangle();
    shapes[1] = new Circle();

    // 각 객체의 draw() 호출 (동적 바인딩)
    // 실제 객체 타입에 따라 적절한 draw() 호출
    shapes[0]->draw();
    shapes[1]->draw();

    delete shapes[0];
    delete shapes[1];


    return 0;
}
```
✅ 중요한점   
가상함수는 하위 객체에서 함수를 구현할수도 있고 안할수도 있다.   
   
✅ 추상 클래스란?   
순수 가상함수가 1개 이상 있으면 이를 추상 클래스라 한다.   
   
✅ 추상 클래스는 객체를 만들수가 없다!   
추상 클래스를 객체로 만들려면, 순수 가상 함수를 모두 구현해야 한다.   
```c++
#include <iostream>

class Shape {
public:
	virtual ~Shape() {}
	virtual void draw() = 0; // (1) 함수가 없다!
};

class Circle : public Shape {
public:
	virtual void draw() {
	std:: cout << "동그라미를 그려요." << std::endl;
	}

};

int main() {
	//Shape s;
	//s.draw();

	Circle c;
	c.draw();

	return 0;
}
```

## 기반클래스 소멸자는 반드시 가상으로

✅ 문제가 없는 경우   
```c++
#include <iostream>

class Base {
public:
	Base()  { std::cout << "Base()" << std::endl; }
	~Base() { std::cout << "~Base()" << std::endl; }
};

class Derived : public Base {
public:
	Derived()  { std::cout << "Derived()" << std::endl; }
	~Derived() { std::cout << "~Derived()" << std::endl; }
};

int main(void) {
	Base* b = new Base();
	delete b;
	
	std::cout << std::endl;
	Derived* d = new Derived();
	delete d;


	return (0);
}
```
<img src="https://github.com/user-attachments/assets/9f4e0008-a6a6-4b4a-a668-172421f19129" width="300" height="100">   
   
✅ 업캐스팅이후 파생 객체를 지울때 문제가 생길수 있다.   
그렇지 않으면 자원 누수   
```c++
#include <iostream>

class Base {
public:
	Base()  { std::cout << "Base()" << std::endl; }
	//~Base() { std::cout << "~Base()" << std::endl; } // (1)
	virtual ~Base() { std::cout << "~Base()" << std::endl; }
};

class Derived : public Base {
public:
	Derived()  { std::cout << "Derived()" << std::endl; }
	~Derived() { std::cout << "~Derived()" << std::endl; }
};

int main(void) {
	//Base* b = new Base();
	//delete b;
	//
	//std::cout << std::endl;
	//Derived* d = new Derived();
	//delete d;

	Base* b2 = new Derived();
	delete b2; // 기반 클래스가 비가상 소멸자라면, 어떻게 동작해야 할지 정의되어 있지 않다.

	return (0);
}
```
virtual ~Base()   
<img src="https://github.com/user-attachments/assets/13211a59-a50d-45db-99c1-d1e6096a3e1c" width="300" height="100">   
Base()   
<img src="https://github.com/user-attachments/assets/04292ae4-90bd-4fb8-93c0-24461565fa20" width="300" height="100">   

## 정적 vs 동적 바인딩

🔹 정적 바인딩: 어떤 파일이 컴파일될지 컴파일 시점에 결정돼있다. (virtual 함수 사용 X)   
🔹 동적 바인딩: 어떤 파일이 컴파일될지 컴파일 시점에 결정되지 않았다. (virtual 함수 사용 O)   
```c++
Shape* shape[10];          // 정적바인딩은 Shape*를 보고
shape[0] = new Rectangle() // 동적바인딩은 new Rectangle()을 본다.
```

# 연산자 오버로딩

## point 예시
✅ 첫번째 연산자 오버로딩을 해보자   
```c++
#include <iostream>

class Point {
private:
	int x;
	int y;
public:
	Point() : x{ 0 }, y{ 0 } {} // 기본 생성자
	Point(int x, int y) : x{ x }, y{ y } {// 매개 변수 생성자
	}
	void print() const {
		std::cout << "(" << x << ", " << y << ")" << std::endl;
	}
	Point operator+(const Point& other) const { //  point + int  -> point.operator+(int)
		return Point(this->x + other.x, this->y + other.y); 
	}
};

int main(void) {

	Point pt1 = { 11,22 };
	Point pt2 = { 22,33 };

	pt1.print();
	pt2.print();

	Point pt3 = pt1 + pt2;
	pt3.print();

	return 0;
}
```   
✅ 복소수의 + 연산자를 오버로딩해보자   
```c++
#include <iostream>

class ComplexNumber {
private:
	int a;
	int b;
public:
	ComplexNumber() : a{ 0 }, b{ 0 } {} // 기본 생성자

	ComplexNumber(int a, int b) : a{ a }, b{ b } {// 매개 변수 생성자
	}

	void print() const {
		std::cout << a << "+" << b << "i" << std::endl;
	}

	ComplexNumber operator+(const ComplexNumber& other) const { // (1)
		return ComplexNumber(this->a + other.a, this->b + other.b);
	}
};

int main(void) {

	ComplexNumber c1 = { 1,2 };
	ComplexNumber c2 = { 3,4 };

	c1.print();
	c2.print();

	ComplexNumber c3 = c1 + c2;
	c3.print();

	return 0;
}
```

✅ 클래스 내부에 만드는 방법 vs 외부에 만드는 방법   
그때그때 편한걸로 쓰면 됨. 양쪽에 만들면 안 됨. 내부에 만들게 되면 private에 접근이 용이함. 외부에는 friend로 만들어야함. 근데 외부에 만드는게 선호됨.   
<img src="https://github.com/user-attachments/assets/da364064-3f34-4940-a05b-94b2bee19c35" width="300" height="100">   

## String '+' 오버로딩
```c++
//c++
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <cstring> // strlen, strcpy, strcat 사용

class MyString {
private:
    char* str; // 문자열 데이터
    size_t len; // 문자열 길이

public:

    MyString() : str{ nullptr }, len{ 0 } {} // 기본 생성자

    MyString(const char* inputStr) { // 매개변수 생성자
        // 입력받은 문자열의 길을 알아낸후
        // 동적 배열을 할당하고
        // 멤버 변수 str에 대입한다.
        len = strlen(inputStr); // 입력 문자열의 길이 계산
        str = new char[len + 1]; // 동적 메모리 할당
        strcpy(str, inputStr); // 문자열 복사
    }

    ~MyString() { // 소멸자
        delete[] str; // 동적 메모리 해제
    }

    // + 연산자 오버로딩 (두 문자열 합치기)
    friend MyString operator+(const MyString& lhs, const MyString& rhs) {
        // 두 문자열의 길이 합을 구한다.
        // MyString으로 생성자가 호출될때 MyString의 멤버 변수 len에 사이즈가 이미 들어가 있다.
        size_t tmpLen = lhs.len + rhs.len;
        char* newStr = new char[tmpLen + 1]; // 새 문자열 메모리 할당

        strcpy(newStr, lhs.str); // 첫 번째 문자열 복사
        strcat(newStr, rhs.str); // 두 번째 문자열 이어붙이기

        MyString result(newStr); // 결과 객체 생성
        delete[] newStr; // 임시 메모리 해제

        return result;
    }

    const char* to_string() const {
        return str;
    }
};

int main() {
    MyString str1("abc");
    MyString str2("xyz");

    printf("첫 번째 문자열: %s\n", str1.to_string());
    printf("두 번째 문자열: %s\n", str2.to_string());

    MyString result = str1 + str2; // 사용자 정의 + 연산자 호출
    printf("결과 문자열: %s\n", result.to_string());

    return 0;
}
```
## Functor (펑터)

✅ 예시   
```c++
//c++
#include <iostream>

class Plus {
public:
    int operator()(int a, int b)  {
        return a + b;
    }

    int operator()(int a, int b, int c) {
        return a + b +c;
    }
};


int main() {
    Plus plus;

    int a = plus(1, 2); // 함수 같지만 함수가 아니야. 함수 객체 Functor라고 부른다.
    //plus 객체가 () 함수처럼 요청할경우 operator ()를 찾아서 호출한다.
    std::cout << a << std::endl;

    int b = plus(1, 2, 3);
    std::cout << b << std::endl;

    return 0;
}
```
✅ functor는 상태를 저장할수 있다.   
```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// functor 
class cmp {

public:
	int value = 0;
	bool operator()(int a, int b) {
		return a > b;
	}
	void operator()(int a) {
		value += a;
	}
};
int main() {
	auto t = cmp();
	t(3);
	t(7);
	cout << t.value;
	cout << endl;

	std::vector<int> arr = { 1,5,2,1,3 };
	sort(arr.begin(), arr.end(), cmp());
	for (int ele : arr) {
		std::cout << ele << ", ";
	}


	return 0;
}
```   
펑터는 객체 지향적인 설계와 유연성을 제공하며, 상태를 유지할 수 있어 더 강력한 기능을 제공한다.   
함수 포인터는 간단하고 빠르게 사용할 수 있지만, 상태를 유지하지 못하고 확장성이 부족하다.   
```c++
#include <iostream>
#include <vector>
#include <algorithm>

bool descending(int a, int b) {
    return a > b; // 내림차순 기준
}

bool ascending(int a, int b) {
    return a < b; // 내림차순 기준
}

int main() {
    std::vector<int> vect = { 5, 2, 8, 1, 3 };

    std::sort(vect.begin(), vect.end(), descending);
    for (int num : vect) {
        std::cout << num << " "; // 출력: 8 5 3 2 1
    }
    std::cout << std::endl;

    std::sort(vect.begin(), vect.end(), ascending);
    for (int num : vect) {
        std::cout << num << " "; // 출력:12358
    }
    std::cout << std::endl;

    return 0;
}
```

## 증감 연산자 ++, —를 오버로딩
```c++
#include <iostream>

class Point {
private:
    int x;
    int y;

public:
    // 기본 생성자
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // 출력 함수 (디버깅용)
    void print() const {
        std::cout << "(" << x << ", " << y << ")" << std::endl;
    }

    // 전위 증가 연산자 (++Point)
    Point& operator++() {
        ++x; // x 증가
        ++y; // y 증가
        return *this; // 자기 자신 반환
    }

    // 후위 증가 연산자 (Point++)
    Point operator++(int) {
        Point temp = *this; // 현재 상태 저장
        ++(*this);          // 전위 증가 호출
        return temp;        // 저장된 상태 반환
    }

    // 전위 감소 연산자 (--Point)
    Point& operator--() {
        --x; // x 감소
        --y; // y 감소
        return *this; // 자기 자신 반환
    }

    // 후위 감소 연산자 (Point--)
    Point operator--(int) {
        Point temp = *this; // 현재 상태 저장
        --(*this);          // 전위 감소 호출
        return temp;        // 저장된 상태 반환
    }
};

int main() {
    Point p(5, 10);

    std::cout << "초기 상태: ";
    p.print();

    std::cout << "전위 증가 (++p): ";
    ++p;
    p.print();

    std::cout << "후위 증가 (p++): ";
    p++;
    p.print();

    //std::cout << "전위 감소 (--p): ";
    //--p;
    //p.print();

    //std::cout << "후위 감소 (p--): ";
    //p--;
    //p.print();

    return 0;
}
```

# template

## 템플릿이란?
✅ 템플릿의 종류   
🔹함수 템플릿(Function Templates)   
🔹클래스 템플릿 (Class Templates)   
   
✅ 템플릿의 장단점   
   
🔹장점
- 코드의 재사용성: 동일한 로직을 여러 데이터 타입에 대해 재사용가능하다.   
- 컴파일 타임 최적화: 컴파일러가 인스턴스화된 코드를 생성하므로 런타임 오버헤드가 없다.   
   
🔹단점   
- 코드 크기 증가: 여러 데이터 타입에 대해 인스턴스화 되므로 코드 크기가 증가한다.   
- 디버깅 어려움: 컴파일시 생성된 코드로 인해 디버깅이 복잡해질수 있다.(컴파일 시 위에 선언된 템플렛 코드를 그대로 다 가져오기때문. 100줄이면 100줄 200줄이면 200줄)   
   
✅ 템플릿 vs 오버로딩   
🔹두개를 비교하기 위한 간단한 코드   
```c++
#include <iostream>
template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << "int: " << add(3, 4) << std::endl;       // int
    std::cout << "double: " << add(3.3, 4.4) << std::endl; // double
    return 0;
}
```
```c++
#include <iostream>
int add(int a, int b) {
    return (a + b);
}
double add(double a, double b) {
    return (a + b);
}

int main() {
    std::cout << "int: " << add(3, 4) << std::endl;       // int
    std::cout << "double: " << add(3.3, 4.4) << std::endl; // double
    return 0;
}
```

## 간단한 예시
```c++
#include <iostream>

template <typename T> 
T add(T x, T y) {
	return (x + y);
}

int main(void) {
	int a = 3;
	int b = 2;
	int r1 = add<int>(a, b); // (1) 
	std::cout << "add(" << a << "," << b << ") = " << r1 << std::endl;
	

	double c = 3.3;
	double d = 4.4;

	double r2 = add<double>(c, d); // (2)
	std::cout << "add(" << c << "," << d << ") = " << r2 << std::endl;

	std::string s1 = "abc";
	std::string s2 = "def";
	std::string r3 = add<std::string>(s1, s2); // (3) 심지어문자열도 가능하다.

	std::cout << "add(" << s1 << "," << s2 << ") = " << r3 << std::endl;


	return 0;
}
```   
(1)에서 함수를 만든다.   
(2)에서도 함수를 만든다.   
(1)과 같은 문장을 만나면 매번 함수를 만나는게 아니라, 한번 만들고 재사용한다.   
그래서 컴파일 시간이 좀 늘어나긴 한다. 실행속도가 늘어나는건 아니다.   

## 템플릿 함수 연습문제
✅ 템플릿 함수로 a, b 중 큰 값 구하기   
템플릿 함수를 작성하고 int, double, string으로 테스트해보자.   
```c++
template <typename T>
T max(T a, T b) {
    // Write your code
}
```
   
풀이   
```c++
template <typename T>
T my_max(T a, T b) {
    return (a > b) ? a : b;
}
```   
   
✅ 템플릿 함수로 배열의 합 구하기   
```c++
template <typename T>
T arraySum(T arr[], int size) {
    // Write your code
}
```   
   
풀이   
```c++
template<typename T>
T arraySum(T a[], int size) {
	T sum = 0;
	for (int i = 0; i < size;i++) {
		sum += a[i];
	}
	return sum;
}
```

## 클래스 템플릿
함수 템플릿도 쓰이지만 클래스 템플릿이 더 많이 쓰인다.   
```c++
#include <iostream>

template <typename T>
class Data {
private:
    T data;
public:
    Data(T d) : data(d) {}
    T getData () {
        return data;
    }
};

class Point {
public: 
    int x;
    int y;

    Point(int x, int y) : x{ x }, y{ y } {}
};

int main() {
    Data<int> data1(123); // 정수형 데이터 저장
    std::cout << "int Data: (" << data1.getData()<< ")" << std::endl;

    Data<double> data2(3.14); // 실수형 데이터 저장
    std::cout << "double Data: (" << data2.getData() << ")" << std::endl;

    Data<std::string>data3("Hello"); // 문자열 데이터 저장
    std::cout << "string Data: (" << data3.getData() << ")" << std::endl;
    
    Data<Point> data4(Point(11, 22)); // 사용자 정의 데이터 저장
    Point pt = data4.getData();
    std::cout << "Point Data: (" << pt.x << ", " << pt.y << ")" << std::endl;

    return 0;
}
```

## 템플릿 특수화
✅ 템플릿 특수화: 템플릿을 만들기가 애매한 경우   
```c++
char* max(char* a, char *b) { // (2) 이 함수는 어떤 결과를 돌려줘야 하는가?}

max("abc", "xyzw"); // (1) 이렇게 입력했을때
```
   
바로 이렇게 하면 된다.   
```c++
#include <iostream>
#include <cstring> // strlen 함수 사용을 위해 필요

template <typename T>
T Max(T a, T b) {
    return a > b ? a : b;
}

// 템플릿 특수화: char* 타입에 대한 Max 함수
// 템플릿 특수화를 사용하기 전에 반드시 일반 템플릿 선언이 정의되어 있어야 한다.
template <>
char* Max(char* a, char* b) {
    return strlen(a) > strlen(b) ? a : b;
}

int main() {
    char str1[] = "aaa";
    char str2[] = "12345";

    // Max 함수 호출
    char* longest = Max(str1, str2);
    std::cout << longest << std::endl;

    return 0;
}
```   
   
✅ 템플릿 특수화: 특정 타입(double)에 대해 클래스 템플릿을 특수화하겠다.   
```c++
#include <iostream>
using namespace std;

// 기본 템플릿
template <typename T>
class MyClass {
public:
    void display() {
        cout << "Generic template" << endl;
    }
};

// 특수화: int 타입에 대한 처리
template <>
class MyClass<double> {
public:
    void display() {
        cout << "Specialized template for double" << endl;
    }
};

int main() {
    MyClass<int> obj1;
    obj1.display(); // Generic template

    MyClass<double> obj2;
    obj2.display(); // Specialized template for int

    return 0;
}
```   
   
✅ max 함수를 함수 작성하되, string에 대해서 특수화   
```c++
// string
#include <iostream>
#include <string>

// 일반 템플릿 함수
template <typename T>
T Max(T a, T b) {
    return (a > b) ? a : b;
}

// std::string 타입에 대한 특수화
template <>
std::string Max<std::string>(std::string a, std::string b) {
    return (a > b) ? a : b; // 사전순 비교
}

int main() {
    // 정수 비교
    std::cout << "Max of 10 and 20: " << Max(10, 20) << std::endl;

    // 문자열 비교
    std::cout << "Max of \"apple\" and \"banana\": " << Max(std::string("apple"), std::string("banana")) << std::endl;

    return 0;
}
```

# 예외처리
## try-catch
✅  왜 예외? if-else도 있잖아   
if-else를 사용하면 코드가 지저분해질 수 있음.   
   
✅ try-cath 키워드 3가지 및 문법   
- try: 예외를 발견한다.   
- catch: 예외를 잡는다.   
- throws: 예외를 던진다.   
```c++
try {
	// 예외가 발생할수 있는 구문
	if(예외가발생했다면) { throw x; } // (1) x를 던진다.
}
catch(type exception) { // (2) 던진 x를 여기서 잡는다.
	// 여기서 예외 처리를 하면 된다.
}
```   
✅ 하나의 try, 다수의 catch 블럭   
```c++
try {
	if(예외가발생했다면) { throw ex; }
}
catch(type ex1) {
}
catch(type ex2) { // (1) 필요한 만큼 적으면 된다.
}
catch(type ex3) {
}
```
✅ 예제: try-catch를 이용한 예외 처리   
```c++
#include <iostream>

int divide(int a, int b);

int main(void) {
	int a = 0;
	int b = 0;

	std::cout << "두 개의 숫자를 입력하세요 : ";
	std::cin >> a >> b;

	try {
		if (b == 0) { throw b; } // (1) 예외가 발생하면 b를 던진다.
		std::cout << "나눗셈의 몫은 " << divide(a, b) << "입니다." << std::endl;
	}
	catch(int exception) { // (2) exception은 b를 받는다. 
		// (3) 이때 예외b의 데이터형과 exception의 데이터형은 일치해야 한다.
		std::cout << "젯수로 "<<exception<<"을 입력하면 안됩니다." << std::endl;
		std::cout << "숫자를 다시 올바르게 입력해 주세요." << std::endl;		
	}
	return 0;
}

int divide(int a, int b) {
	return (a / b);
}
```

## 스팩 풀기
✅ 스택 풀기란? (What is Stack Unwinding?)   
어떤 함수에서 발생한 예외가 이 함수를 호출한 함수로 계속 전달되는 것을 말한다. 예를 들어, bts → exo → ses 
순서로 함수를 호출했음. ses에서 예외 발생했다 가정하자. 이 예외가 호출한 함수에게 계속 전달되는 상황을 말한다. 즉, bts ← exo ← ses 순서로 예외가 전달된다.   
   
물론 중간 함수인 exo에서 예외를 처리하면, bts까지 전달되지는 않는다. 만일 bts 마저도 예외를 처리하지 않으면, 
엔트리포인트인 main까지 전달되고 main이 처리를 해주면 되겠지만, main이 처리를 못해주면, 
프로그램이 예외를 처리하지 못해 종료된다.   
   
✅ divide 함수가 예외를 던지게 바꾸기   
```c++
int divide(int a, int b) {
	return (a / b);
}
```
```c++
int divide(int a, int b) {
	if (b == 0) { throw b; }
	else {
		return (a / b);
	}
}
```   
✅ 예제: divide 함수가 던지는 예외를 받기, 스택 풀기   
```c++
#include <iostream>

int divide(int a, int b);

int main(void) {
	int a = 0;
	int b = 0;

	std::cout << "두 개의 숫자를 입력하세요 : ";
	std::cin >> a >> b;

	try {
		std::cout << "나눗셈의 몫은 " << divide(a, b) << "입니다." << std::endl; //(1)
	}
	catch(int exception) {
		std::cout << "젯수로 "<<exception<<"을 입력하면 안됩니다." << std::endl;
		std::cout << "숫자를 다시 올바르게 입력해 주세요." << std::endl;		
	}
	return 0;
}

int divide(int a, int b) {
	if (b == 0) { throw b; } //(2)
	else {
		return (a / b);
	}
}
```
(1)에서 호출한 함수 divide가 (2)에서 예외를 발생할 경우, (1)로 돌아온다.   
   
✅ 예제: 스택 풀기   
```c++
#include <iostream>

void bts(void);
void exo(void);
void ses(void);

void bts(void) {
	std::cout << "bts()" << std::endl;
	exo();
}

void exo(void) {
	std::cout << "exo()" << std::endl;
	ses();
}

void ses(void) {
	std::cout << "ses()" << std::endl;
	throw (123);
}


int main(void) {
	try {
  	std::cout << "main()" << std::endl;
		bts();
	}
	catch (int exception) {
		std::cout << "exception: " << exception << std::endl;
	}

	bts();

	return 0;
}
```   
   
✅ 전달되는 예외의 명시:  이렇게 사용하자.   
위의 예제에서 함수를 이렇게 작성했는데   
```c++
int divide(int a, int b) { // 생략 (1)
```   
가급적이면 이렇게 작성하는게 좋다.   
```c++
int divide(int a, int b) throw(int) { // 생략 (2)
```   
   
저 함수를 사용하는 클라이언트는 아무래도 이렇게 코딩할 확률이 높음   
```c++
int a= 3;
int b= 4;
try {
	divide(a, b);
}
catch(exception e) {
	std::cout<<"aaa";
}
```
try-catch 구문을 사용하지 않는다 않고, 아래와 같이 사용하더라도 저 divide 함수가 뭔가 예외를 던진다는 
것을 인지하기 때문에 (2)와 같이 함수를 만드는게 더 좋다.
